// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.5.1
// - protoc             v3.21.12
// source: pb/pkcs11.proto

package pb

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	CryptographicToken_Initialize_FullMethodName          = "/pb.CryptographicToken/Initialize"
	CryptographicToken_Finalize_FullMethodName            = "/pb.CryptographicToken/Finalize"
	CryptographicToken_GetInfo_FullMethodName             = "/pb.CryptographicToken/GetInfo"
	CryptographicToken_GetFunctionList_FullMethodName     = "/pb.CryptographicToken/GetFunctionList"
	CryptographicToken_GetInterfaceList_FullMethodName    = "/pb.CryptographicToken/GetInterfaceList"
	CryptographicToken_GetInterface_FullMethodName        = "/pb.CryptographicToken/GetInterface"
	CryptographicToken_GetSlotList_FullMethodName         = "/pb.CryptographicToken/GetSlotList"
	CryptographicToken_GetSlotInfo_FullMethodName         = "/pb.CryptographicToken/GetSlotInfo"
	CryptographicToken_GetTokenInfo_FullMethodName        = "/pb.CryptographicToken/GetTokenInfo"
	CryptographicToken_WaitForSlotEvent_FullMethodName    = "/pb.CryptographicToken/WaitForSlotEvent"
	CryptographicToken_GetMechanismList_FullMethodName    = "/pb.CryptographicToken/GetMechanismList"
	CryptographicToken_GetMechanismInfo_FullMethodName    = "/pb.CryptographicToken/GetMechanismInfo"
	CryptographicToken_InitToken_FullMethodName           = "/pb.CryptographicToken/InitToken"
	CryptographicToken_InitPIN_FullMethodName             = "/pb.CryptographicToken/InitPIN"
	CryptographicToken_SetPIN_FullMethodName              = "/pb.CryptographicToken/SetPIN"
	CryptographicToken_OpenSession_FullMethodName         = "/pb.CryptographicToken/OpenSession"
	CryptographicToken_CloseSession_FullMethodName        = "/pb.CryptographicToken/CloseSession"
	CryptographicToken_CloseAllSessions_FullMethodName    = "/pb.CryptographicToken/CloseAllSessions"
	CryptographicToken_GetSessionInfo_FullMethodName      = "/pb.CryptographicToken/GetSessionInfo"
	CryptographicToken_SessionCancel_FullMethodName       = "/pb.CryptographicToken/SessionCancel"
	CryptographicToken_CreateObject_FullMethodName        = "/pb.CryptographicToken/CreateObject"
	CryptographicToken_CopyObject_FullMethodName          = "/pb.CryptographicToken/CopyObject"
	CryptographicToken_DestroyObject_FullMethodName       = "/pb.CryptographicToken/DestroyObject"
	CryptographicToken_GetObjectSize_FullMethodName       = "/pb.CryptographicToken/GetObjectSize"
	CryptographicToken_GetAttributeValue_FullMethodName   = "/pb.CryptographicToken/GetAttributeValue"
	CryptographicToken_SetAttributeValue_FullMethodName   = "/pb.CryptographicToken/SetAttributeValue"
	CryptographicToken_FindObjectsInit_FullMethodName     = "/pb.CryptographicToken/FindObjectsInit"
	CryptographicToken_FindObjects_FullMethodName         = "/pb.CryptographicToken/FindObjects"
	CryptographicToken_FindObjectsFinal_FullMethodName    = "/pb.CryptographicToken/FindObjectsFinal"
	CryptographicToken_EncryptInit_FullMethodName         = "/pb.CryptographicToken/EncryptInit"
	CryptographicToken_Encrypt_FullMethodName             = "/pb.CryptographicToken/Encrypt"
	CryptographicToken_EncryptUpdate_FullMethodName       = "/pb.CryptographicToken/EncryptUpdate"
	CryptographicToken_EncryptFinal_FullMethodName        = "/pb.CryptographicToken/EncryptFinal"
	CryptographicToken_EncryptMessageInit_FullMethodName  = "/pb.CryptographicToken/EncryptMessageInit"
	CryptographicToken_EncryptMessage_FullMethodName      = "/pb.CryptographicToken/EncryptMessage"
	CryptographicToken_EncryptMessageBegin_FullMethodName = "/pb.CryptographicToken/EncryptMessageBegin"
	CryptographicToken_EncryptMessageNext_FullMethodName  = "/pb.CryptographicToken/EncryptMessageNext"
	CryptographicToken_EncryptMessageFinal_FullMethodName = "/pb.CryptographicToken/EncryptMessageFinal"
	CryptographicToken_DecryptInit_FullMethodName         = "/pb.CryptographicToken/DecryptInit"
	CryptographicToken_Decrypt_FullMethodName             = "/pb.CryptographicToken/Decrypt"
	CryptographicToken_DecryptUpdate_FullMethodName       = "/pb.CryptographicToken/DecryptUpdate"
	CryptographicToken_DecryptFinal_FullMethodName        = "/pb.CryptographicToken/DecryptFinal"
	CryptographicToken_DecryptMessageInit_FullMethodName  = "/pb.CryptographicToken/DecryptMessageInit"
	CryptographicToken_DecryptMessage_FullMethodName      = "/pb.CryptographicToken/DecryptMessage"
	CryptographicToken_DecryptMessageBegin_FullMethodName = "/pb.CryptographicToken/DecryptMessageBegin"
	CryptographicToken_DecryptMessageNext_FullMethodName  = "/pb.CryptographicToken/DecryptMessageNext"
	CryptographicToken_MessageDecryptFinal_FullMethodName = "/pb.CryptographicToken/MessageDecryptFinal"
	CryptographicToken_DigestInit_FullMethodName          = "/pb.CryptographicToken/DigestInit"
	CryptographicToken_Digest_FullMethodName              = "/pb.CryptographicToken/Digest"
	CryptographicToken_DigestUpdate_FullMethodName        = "/pb.CryptographicToken/DigestUpdate"
	CryptographicToken_DigestKey_FullMethodName           = "/pb.CryptographicToken/DigestKey"
	CryptographicToken_DigestFinal_FullMethodName         = "/pb.CryptographicToken/DigestFinal"
	CryptographicToken_SignInit_FullMethodName            = "/pb.CryptographicToken/SignInit"
	CryptographicToken_Sign_FullMethodName                = "/pb.CryptographicToken/Sign"
	CryptographicToken_SignUpdate_FullMethodName          = "/pb.CryptographicToken/SignUpdate"
	CryptographicToken_SignFinal_FullMethodName           = "/pb.CryptographicToken/SignFinal"
	CryptographicToken_SignRecoverInit_FullMethodName     = "/pb.CryptographicToken/SignRecoverInit"
	CryptographicToken_SignRecover_FullMethodName         = "/pb.CryptographicToken/SignRecover"
	CryptographicToken_SignMessageInit_FullMethodName     = "/pb.CryptographicToken/SignMessageInit"
	CryptographicToken_SignMessage_FullMethodName         = "/pb.CryptographicToken/SignMessage"
	CryptographicToken_SignMessageBegin_FullMethodName    = "/pb.CryptographicToken/SignMessageBegin"
	CryptographicToken_SignMessageNext_FullMethodName     = "/pb.CryptographicToken/SignMessageNext"
	CryptographicToken_SignMessageFinal_FullMethodName    = "/pb.CryptographicToken/SignMessageFinal"
	CryptographicToken_VerifyInit_FullMethodName          = "/pb.CryptographicToken/VerifyInit"
	CryptographicToken_Verify_FullMethodName              = "/pb.CryptographicToken/Verify"
	CryptographicToken_VerifyUpdate_FullMethodName        = "/pb.CryptographicToken/VerifyUpdate"
	CryptographicToken_VerifyFinal_FullMethodName         = "/pb.CryptographicToken/VerifyFinal"
	CryptographicToken_VerifyRecoverInit_FullMethodName   = "/pb.CryptographicToken/VerifyRecoverInit"
	CryptographicToken_VerifyRecover_FullMethodName       = "/pb.CryptographicToken/VerifyRecover"
	CryptographicToken_VerifyMessageInit_FullMethodName   = "/pb.CryptographicToken/VerifyMessageInit"
	CryptographicToken_VerifyMessage_FullMethodName       = "/pb.CryptographicToken/VerifyMessage"
	CryptographicToken_VerifyMessageBegin_FullMethodName  = "/pb.CryptographicToken/VerifyMessageBegin"
	CryptographicToken_VerifyMessageNext_FullMethodName   = "/pb.CryptographicToken/VerifyMessageNext"
	CryptographicToken_VerifyMessageFinal_FullMethodName  = "/pb.CryptographicToken/VerifyMessageFinal"
	CryptographicToken_DigestEncryptUpdate_FullMethodName = "/pb.CryptographicToken/DigestEncryptUpdate"
	CryptographicToken_DecryptDigestUpdate_FullMethodName = "/pb.CryptographicToken/DecryptDigestUpdate"
	CryptographicToken_SignEncryptUpdate_FullMethodName   = "/pb.CryptographicToken/SignEncryptUpdate"
	CryptographicToken_DecryptVerifyUpdate_FullMethodName = "/pb.CryptographicToken/DecryptVerifyUpdate"
	CryptographicToken_GenerateKey_FullMethodName         = "/pb.CryptographicToken/GenerateKey"
	CryptographicToken_GenerateKeyPair_FullMethodName     = "/pb.CryptographicToken/GenerateKeyPair"
	CryptographicToken_WrapKey_FullMethodName             = "/pb.CryptographicToken/WrapKey"
	CryptographicToken_UnwrapKey_FullMethodName           = "/pb.CryptographicToken/UnwrapKey"
	CryptographicToken_DeriveKey_FullMethodName           = "/pb.CryptographicToken/DeriveKey"
	CryptographicToken_SeedRandom_FullMethodName          = "/pb.CryptographicToken/SeedRandom"
	CryptographicToken_GenerateRandom_FullMethodName      = "/pb.CryptographicToken/GenerateRandom"
	CryptographicToken_GetFunctionStatus_FullMethodName   = "/pb.CryptographicToken/GetFunctionStatus"
	CryptographicToken_CancelFunction_FullMethodName      = "/pb.CryptographicToken/CancelFunction"
)

// CryptographicTokenClient is the client API for CryptographicToken service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type CryptographicTokenClient interface {
	Initialize(ctx context.Context, in *InitializeRequest, opts ...grpc.CallOption) (*InitializeResponse, error)
	Finalize(ctx context.Context, in *FinalizeRequest, opts ...grpc.CallOption) (*FinalizeResponse, error)
	GetInfo(ctx context.Context, in *GetInfoRequest, opts ...grpc.CallOption) (*GetInfoResponse, error)
	GetFunctionList(ctx context.Context, in *GetFunctionListRequest, opts ...grpc.CallOption) (*GetFunctionListResponse, error)
	GetInterfaceList(ctx context.Context, in *GetInterfaceListRequest, opts ...grpc.CallOption) (*GetInterfaceListResponse, error)
	GetInterface(ctx context.Context, in *GetInterfaceRequest, opts ...grpc.CallOption) (*GetInterfaceResponse, error)
	GetSlotList(ctx context.Context, in *GetSlotListRequest, opts ...grpc.CallOption) (*GetSlotListResponse, error)
	GetSlotInfo(ctx context.Context, in *GetSlotInfoRequest, opts ...grpc.CallOption) (*GetSlotInfoResponse, error)
	GetTokenInfo(ctx context.Context, in *GetTokenInfoRequest, opts ...grpc.CallOption) (*GetTokenInfoResponse, error)
	WaitForSlotEvent(ctx context.Context, in *WaitForSlotEventRequest, opts ...grpc.CallOption) (*WaitForSlotEventResponse, error)
	GetMechanismList(ctx context.Context, in *GetMechanismListRequest, opts ...grpc.CallOption) (*GetMechanismListResponse, error)
	GetMechanismInfo(ctx context.Context, in *GetMechanismInfoRequest, opts ...grpc.CallOption) (*GetMechanismInfoResponse, error)
	InitToken(ctx context.Context, in *InitTokenRequest, opts ...grpc.CallOption) (*InitTokenResponse, error)
	InitPIN(ctx context.Context, in *InitPINRequest, opts ...grpc.CallOption) (*InitPINResponse, error)
	SetPIN(ctx context.Context, in *SetPINRequest, opts ...grpc.CallOption) (*SetPINResponse, error)
	OpenSession(ctx context.Context, in *OpenSessionRequest, opts ...grpc.CallOption) (*OpenSessionResponse, error)
	CloseSession(ctx context.Context, in *CloseSessionRequest, opts ...grpc.CallOption) (*CloseSessionResponse, error)
	CloseAllSessions(ctx context.Context, in *CloseAllSessionsRequest, opts ...grpc.CallOption) (*CloseAllSessionsResponse, error)
	GetSessionInfo(ctx context.Context, in *GetSessionInfoRequest, opts ...grpc.CallOption) (*GetSessionInfoResponse, error)
	SessionCancel(ctx context.Context, in *SessionCancelRequest, opts ...grpc.CallOption) (*SessionCancelResponse, error)
	CreateObject(ctx context.Context, in *CreateObjectRequest, opts ...grpc.CallOption) (*CreateObjectResponse, error)
	CopyObject(ctx context.Context, in *CopyObjectRequest, opts ...grpc.CallOption) (*CopyObjectResponse, error)
	DestroyObject(ctx context.Context, in *DestroyObjectRequest, opts ...grpc.CallOption) (*DestroyObjectResponse, error)
	GetObjectSize(ctx context.Context, in *GetObjectSizeRequest, opts ...grpc.CallOption) (*GetObjectSizeResponse, error)
	GetAttributeValue(ctx context.Context, in *GetAttributeValueRequest, opts ...grpc.CallOption) (*GetAttributeValueResponse, error)
	SetAttributeValue(ctx context.Context, in *SetAttributeValueRequest, opts ...grpc.CallOption) (*SetAttributeValueResponse, error)
	FindObjectsInit(ctx context.Context, in *FindObjectsInitRequest, opts ...grpc.CallOption) (*FindObjectsInitResponse, error)
	FindObjects(ctx context.Context, in *FindObjectsRequest, opts ...grpc.CallOption) (*FindObjectsResponse, error)
	FindObjectsFinal(ctx context.Context, in *FindObjectsFinalRequest, opts ...grpc.CallOption) (*FindObjectsFinalResponse, error)
	EncryptInit(ctx context.Context, in *EncryptInitRequest, opts ...grpc.CallOption) (*EncryptInitResponse, error)
	Encrypt(ctx context.Context, in *EncryptRequest, opts ...grpc.CallOption) (*EncryptResponse, error)
	EncryptUpdate(ctx context.Context, in *EncryptUpdateRequest, opts ...grpc.CallOption) (*EncryptUpdateResponse, error)
	EncryptFinal(ctx context.Context, in *EncryptFinalRequest, opts ...grpc.CallOption) (*EncryptFinalResponse, error)
	EncryptMessageInit(ctx context.Context, in *EncryptMessageInitRequest, opts ...grpc.CallOption) (*EncryptMessageInitResponse, error)
	EncryptMessage(ctx context.Context, in *EncryptMessageRequest, opts ...grpc.CallOption) (*EncryptMessageResponse, error)
	EncryptMessageBegin(ctx context.Context, in *EncryptMessageBeginRequest, opts ...grpc.CallOption) (*EncryptMessageBeginResponse, error)
	EncryptMessageNext(ctx context.Context, in *EncryptMessageNextRequest, opts ...grpc.CallOption) (*EncryptMessageNextResponse, error)
	EncryptMessageFinal(ctx context.Context, in *EncryptMessageFinalRequest, opts ...grpc.CallOption) (*EncryptMessageFinalResponse, error)
	DecryptInit(ctx context.Context, in *DecryptInitRequest, opts ...grpc.CallOption) (*DecryptInitResponse, error)
	Decrypt(ctx context.Context, in *DecryptRequest, opts ...grpc.CallOption) (*DecryptResponse, error)
	DecryptUpdate(ctx context.Context, in *DecryptUpdateRequest, opts ...grpc.CallOption) (*DecryptUpdateResponse, error)
	DecryptFinal(ctx context.Context, in *DecryptFinalRequest, opts ...grpc.CallOption) (*DecryptFinalResponse, error)
	DecryptMessageInit(ctx context.Context, in *DecryptMessageInitRequest, opts ...grpc.CallOption) (*DecryptMessageInitResponse, error)
	DecryptMessage(ctx context.Context, in *DecryptMessageRequest, opts ...grpc.CallOption) (*DecryptMessageResponse, error)
	DecryptMessageBegin(ctx context.Context, in *DecryptMessageBeginRequest, opts ...grpc.CallOption) (*DecryptMessageBeginResponse, error)
	DecryptMessageNext(ctx context.Context, in *DecryptMessageNextRequest, opts ...grpc.CallOption) (*DecryptMessageNextResponse, error)
	MessageDecryptFinal(ctx context.Context, in *MessageDecryptFinalRequest, opts ...grpc.CallOption) (*MessageDecryptFinalResponse, error)
	DigestInit(ctx context.Context, in *DigestInitRequest, opts ...grpc.CallOption) (*DigestInitResponse, error)
	Digest(ctx context.Context, in *DigestRequest, opts ...grpc.CallOption) (*DigestResponse, error)
	DigestUpdate(ctx context.Context, in *DigestUpdateRequest, opts ...grpc.CallOption) (*DigestUpdateResponse, error)
	DigestKey(ctx context.Context, in *DigestKeyRequest, opts ...grpc.CallOption) (*DigestKeyResponse, error)
	DigestFinal(ctx context.Context, in *DigestFinalRequest, opts ...grpc.CallOption) (*DigestFinalResponse, error)
	SignInit(ctx context.Context, in *SignInitRequest, opts ...grpc.CallOption) (*SignInitResponse, error)
	Sign(ctx context.Context, in *SignRequest, opts ...grpc.CallOption) (*SignResponse, error)
	SignUpdate(ctx context.Context, in *SignUpdateRequest, opts ...grpc.CallOption) (*SignUpdateResponse, error)
	SignFinal(ctx context.Context, in *SignFinalRequest, opts ...grpc.CallOption) (*SignFinalResponse, error)
	SignRecoverInit(ctx context.Context, in *SignRecoverInitRequest, opts ...grpc.CallOption) (*SignRecoverInitResponse, error)
	SignRecover(ctx context.Context, in *SignRecoverRequest, opts ...grpc.CallOption) (*SignRecoverResponse, error)
	SignMessageInit(ctx context.Context, in *SignMessageInitRequest, opts ...grpc.CallOption) (*SignMessageInitResponse, error)
	SignMessage(ctx context.Context, in *SignMessageRequest, opts ...grpc.CallOption) (*SignMessageResponse, error)
	SignMessageBegin(ctx context.Context, in *SignMessageBeginRequest, opts ...grpc.CallOption) (*SignMessageBeginResponse, error)
	SignMessageNext(ctx context.Context, in *SignMessageNextRequest, opts ...grpc.CallOption) (*SignMessageNextResponse, error)
	SignMessageFinal(ctx context.Context, in *SignMessageFinalRequest, opts ...grpc.CallOption) (*SignMessageFinalResponse, error)
	VerifyInit(ctx context.Context, in *VerifyInitRequest, opts ...grpc.CallOption) (*VerifyInitResponse, error)
	Verify(ctx context.Context, in *VerifyRequest, opts ...grpc.CallOption) (*VerifyResponse, error)
	VerifyUpdate(ctx context.Context, in *VerifyUpdateRequest, opts ...grpc.CallOption) (*VerifyUpdateResponse, error)
	VerifyFinal(ctx context.Context, in *VerifyFinalRequest, opts ...grpc.CallOption) (*VerifyFinalResponse, error)
	VerifyRecoverInit(ctx context.Context, in *VerifyRecoverInitRequest, opts ...grpc.CallOption) (*VerifyRecoverInitResponse, error)
	VerifyRecover(ctx context.Context, in *VerifyRecoverRequest, opts ...grpc.CallOption) (*VerifyRecoverResponse, error)
	VerifyMessageInit(ctx context.Context, in *VerifyMessageInitRequest, opts ...grpc.CallOption) (*VerifyMessageInitResponse, error)
	VerifyMessage(ctx context.Context, in *VerifyMessageRequest, opts ...grpc.CallOption) (*VerifyMessageResponse, error)
	VerifyMessageBegin(ctx context.Context, in *VerifyMessageBeginRequest, opts ...grpc.CallOption) (*VerifyMessageBeginResponse, error)
	VerifyMessageNext(ctx context.Context, in *VerifyMessageNextRequest, opts ...grpc.CallOption) (*VerifyMessageNextResponse, error)
	VerifyMessageFinal(ctx context.Context, in *VerifyMessageFinalRequest, opts ...grpc.CallOption) (*VerifyMessageFinalResponse, error)
	DigestEncryptUpdate(ctx context.Context, in *DigestEncryptUpdateRequest, opts ...grpc.CallOption) (*DigestEncryptUpdateResponse, error)
	DecryptDigestUpdate(ctx context.Context, in *DecryptDigestUpdateRequest, opts ...grpc.CallOption) (*DecryptDigestUpdateResponse, error)
	SignEncryptUpdate(ctx context.Context, in *SignEncryptUpdateRequest, opts ...grpc.CallOption) (*SignEncryptUpdateResponse, error)
	DecryptVerifyUpdate(ctx context.Context, in *DecryptVerifyUpdateRequest, opts ...grpc.CallOption) (*DecryptVerifyUpdateResponse, error)
	GenerateKey(ctx context.Context, in *GenerateKeyRequest, opts ...grpc.CallOption) (*GenerateKeyResponse, error)
	GenerateKeyPair(ctx context.Context, in *GenerateKeyPairRequest, opts ...grpc.CallOption) (*GenerateKeyPairResponse, error)
	WrapKey(ctx context.Context, in *WrapKeyRequest, opts ...grpc.CallOption) (*WrapKeyResponse, error)
	UnwrapKey(ctx context.Context, in *UnwrapKeyRequest, opts ...grpc.CallOption) (*UnwrapKeyResponse, error)
	DeriveKey(ctx context.Context, in *DeriveKeyRequest, opts ...grpc.CallOption) (*DeriveKeyResponse, error)
	SeedRandom(ctx context.Context, in *SeedRandomRequest, opts ...grpc.CallOption) (*SeedRandomResponse, error)
	GenerateRandom(ctx context.Context, in *GenerateRandomRequest, opts ...grpc.CallOption) (*GenerateRandomResponse, error)
	GetFunctionStatus(ctx context.Context, in *GetFunctionStatusRequest, opts ...grpc.CallOption) (*GetFunctionStatusResponse, error)
	CancelFunction(ctx context.Context, in *CancelFunctionRequest, opts ...grpc.CallOption) (*CancelFunctionResponse, error)
}

type cryptographicTokenClient struct {
	cc grpc.ClientConnInterface
}

func NewCryptographicTokenClient(cc grpc.ClientConnInterface) CryptographicTokenClient {
	return &cryptographicTokenClient{cc}
}

func (c *cryptographicTokenClient) Initialize(ctx context.Context, in *InitializeRequest, opts ...grpc.CallOption) (*InitializeResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(InitializeResponse)
	err := c.cc.Invoke(ctx, CryptographicToken_Initialize_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cryptographicTokenClient) Finalize(ctx context.Context, in *FinalizeRequest, opts ...grpc.CallOption) (*FinalizeResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(FinalizeResponse)
	err := c.cc.Invoke(ctx, CryptographicToken_Finalize_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cryptographicTokenClient) GetInfo(ctx context.Context, in *GetInfoRequest, opts ...grpc.CallOption) (*GetInfoResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetInfoResponse)
	err := c.cc.Invoke(ctx, CryptographicToken_GetInfo_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cryptographicTokenClient) GetFunctionList(ctx context.Context, in *GetFunctionListRequest, opts ...grpc.CallOption) (*GetFunctionListResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetFunctionListResponse)
	err := c.cc.Invoke(ctx, CryptographicToken_GetFunctionList_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cryptographicTokenClient) GetInterfaceList(ctx context.Context, in *GetInterfaceListRequest, opts ...grpc.CallOption) (*GetInterfaceListResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetInterfaceListResponse)
	err := c.cc.Invoke(ctx, CryptographicToken_GetInterfaceList_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cryptographicTokenClient) GetInterface(ctx context.Context, in *GetInterfaceRequest, opts ...grpc.CallOption) (*GetInterfaceResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetInterfaceResponse)
	err := c.cc.Invoke(ctx, CryptographicToken_GetInterface_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cryptographicTokenClient) GetSlotList(ctx context.Context, in *GetSlotListRequest, opts ...grpc.CallOption) (*GetSlotListResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetSlotListResponse)
	err := c.cc.Invoke(ctx, CryptographicToken_GetSlotList_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cryptographicTokenClient) GetSlotInfo(ctx context.Context, in *GetSlotInfoRequest, opts ...grpc.CallOption) (*GetSlotInfoResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetSlotInfoResponse)
	err := c.cc.Invoke(ctx, CryptographicToken_GetSlotInfo_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cryptographicTokenClient) GetTokenInfo(ctx context.Context, in *GetTokenInfoRequest, opts ...grpc.CallOption) (*GetTokenInfoResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetTokenInfoResponse)
	err := c.cc.Invoke(ctx, CryptographicToken_GetTokenInfo_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cryptographicTokenClient) WaitForSlotEvent(ctx context.Context, in *WaitForSlotEventRequest, opts ...grpc.CallOption) (*WaitForSlotEventResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(WaitForSlotEventResponse)
	err := c.cc.Invoke(ctx, CryptographicToken_WaitForSlotEvent_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cryptographicTokenClient) GetMechanismList(ctx context.Context, in *GetMechanismListRequest, opts ...grpc.CallOption) (*GetMechanismListResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetMechanismListResponse)
	err := c.cc.Invoke(ctx, CryptographicToken_GetMechanismList_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cryptographicTokenClient) GetMechanismInfo(ctx context.Context, in *GetMechanismInfoRequest, opts ...grpc.CallOption) (*GetMechanismInfoResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetMechanismInfoResponse)
	err := c.cc.Invoke(ctx, CryptographicToken_GetMechanismInfo_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cryptographicTokenClient) InitToken(ctx context.Context, in *InitTokenRequest, opts ...grpc.CallOption) (*InitTokenResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(InitTokenResponse)
	err := c.cc.Invoke(ctx, CryptographicToken_InitToken_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cryptographicTokenClient) InitPIN(ctx context.Context, in *InitPINRequest, opts ...grpc.CallOption) (*InitPINResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(InitPINResponse)
	err := c.cc.Invoke(ctx, CryptographicToken_InitPIN_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cryptographicTokenClient) SetPIN(ctx context.Context, in *SetPINRequest, opts ...grpc.CallOption) (*SetPINResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SetPINResponse)
	err := c.cc.Invoke(ctx, CryptographicToken_SetPIN_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cryptographicTokenClient) OpenSession(ctx context.Context, in *OpenSessionRequest, opts ...grpc.CallOption) (*OpenSessionResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(OpenSessionResponse)
	err := c.cc.Invoke(ctx, CryptographicToken_OpenSession_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cryptographicTokenClient) CloseSession(ctx context.Context, in *CloseSessionRequest, opts ...grpc.CallOption) (*CloseSessionResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CloseSessionResponse)
	err := c.cc.Invoke(ctx, CryptographicToken_CloseSession_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cryptographicTokenClient) CloseAllSessions(ctx context.Context, in *CloseAllSessionsRequest, opts ...grpc.CallOption) (*CloseAllSessionsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CloseAllSessionsResponse)
	err := c.cc.Invoke(ctx, CryptographicToken_CloseAllSessions_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cryptographicTokenClient) GetSessionInfo(ctx context.Context, in *GetSessionInfoRequest, opts ...grpc.CallOption) (*GetSessionInfoResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetSessionInfoResponse)
	err := c.cc.Invoke(ctx, CryptographicToken_GetSessionInfo_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cryptographicTokenClient) SessionCancel(ctx context.Context, in *SessionCancelRequest, opts ...grpc.CallOption) (*SessionCancelResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SessionCancelResponse)
	err := c.cc.Invoke(ctx, CryptographicToken_SessionCancel_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cryptographicTokenClient) CreateObject(ctx context.Context, in *CreateObjectRequest, opts ...grpc.CallOption) (*CreateObjectResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CreateObjectResponse)
	err := c.cc.Invoke(ctx, CryptographicToken_CreateObject_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cryptographicTokenClient) CopyObject(ctx context.Context, in *CopyObjectRequest, opts ...grpc.CallOption) (*CopyObjectResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CopyObjectResponse)
	err := c.cc.Invoke(ctx, CryptographicToken_CopyObject_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cryptographicTokenClient) DestroyObject(ctx context.Context, in *DestroyObjectRequest, opts ...grpc.CallOption) (*DestroyObjectResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DestroyObjectResponse)
	err := c.cc.Invoke(ctx, CryptographicToken_DestroyObject_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cryptographicTokenClient) GetObjectSize(ctx context.Context, in *GetObjectSizeRequest, opts ...grpc.CallOption) (*GetObjectSizeResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetObjectSizeResponse)
	err := c.cc.Invoke(ctx, CryptographicToken_GetObjectSize_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cryptographicTokenClient) GetAttributeValue(ctx context.Context, in *GetAttributeValueRequest, opts ...grpc.CallOption) (*GetAttributeValueResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetAttributeValueResponse)
	err := c.cc.Invoke(ctx, CryptographicToken_GetAttributeValue_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cryptographicTokenClient) SetAttributeValue(ctx context.Context, in *SetAttributeValueRequest, opts ...grpc.CallOption) (*SetAttributeValueResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SetAttributeValueResponse)
	err := c.cc.Invoke(ctx, CryptographicToken_SetAttributeValue_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cryptographicTokenClient) FindObjectsInit(ctx context.Context, in *FindObjectsInitRequest, opts ...grpc.CallOption) (*FindObjectsInitResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(FindObjectsInitResponse)
	err := c.cc.Invoke(ctx, CryptographicToken_FindObjectsInit_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cryptographicTokenClient) FindObjects(ctx context.Context, in *FindObjectsRequest, opts ...grpc.CallOption) (*FindObjectsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(FindObjectsResponse)
	err := c.cc.Invoke(ctx, CryptographicToken_FindObjects_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cryptographicTokenClient) FindObjectsFinal(ctx context.Context, in *FindObjectsFinalRequest, opts ...grpc.CallOption) (*FindObjectsFinalResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(FindObjectsFinalResponse)
	err := c.cc.Invoke(ctx, CryptographicToken_FindObjectsFinal_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cryptographicTokenClient) EncryptInit(ctx context.Context, in *EncryptInitRequest, opts ...grpc.CallOption) (*EncryptInitResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(EncryptInitResponse)
	err := c.cc.Invoke(ctx, CryptographicToken_EncryptInit_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cryptographicTokenClient) Encrypt(ctx context.Context, in *EncryptRequest, opts ...grpc.CallOption) (*EncryptResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(EncryptResponse)
	err := c.cc.Invoke(ctx, CryptographicToken_Encrypt_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cryptographicTokenClient) EncryptUpdate(ctx context.Context, in *EncryptUpdateRequest, opts ...grpc.CallOption) (*EncryptUpdateResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(EncryptUpdateResponse)
	err := c.cc.Invoke(ctx, CryptographicToken_EncryptUpdate_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cryptographicTokenClient) EncryptFinal(ctx context.Context, in *EncryptFinalRequest, opts ...grpc.CallOption) (*EncryptFinalResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(EncryptFinalResponse)
	err := c.cc.Invoke(ctx, CryptographicToken_EncryptFinal_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cryptographicTokenClient) EncryptMessageInit(ctx context.Context, in *EncryptMessageInitRequest, opts ...grpc.CallOption) (*EncryptMessageInitResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(EncryptMessageInitResponse)
	err := c.cc.Invoke(ctx, CryptographicToken_EncryptMessageInit_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cryptographicTokenClient) EncryptMessage(ctx context.Context, in *EncryptMessageRequest, opts ...grpc.CallOption) (*EncryptMessageResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(EncryptMessageResponse)
	err := c.cc.Invoke(ctx, CryptographicToken_EncryptMessage_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cryptographicTokenClient) EncryptMessageBegin(ctx context.Context, in *EncryptMessageBeginRequest, opts ...grpc.CallOption) (*EncryptMessageBeginResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(EncryptMessageBeginResponse)
	err := c.cc.Invoke(ctx, CryptographicToken_EncryptMessageBegin_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cryptographicTokenClient) EncryptMessageNext(ctx context.Context, in *EncryptMessageNextRequest, opts ...grpc.CallOption) (*EncryptMessageNextResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(EncryptMessageNextResponse)
	err := c.cc.Invoke(ctx, CryptographicToken_EncryptMessageNext_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cryptographicTokenClient) EncryptMessageFinal(ctx context.Context, in *EncryptMessageFinalRequest, opts ...grpc.CallOption) (*EncryptMessageFinalResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(EncryptMessageFinalResponse)
	err := c.cc.Invoke(ctx, CryptographicToken_EncryptMessageFinal_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cryptographicTokenClient) DecryptInit(ctx context.Context, in *DecryptInitRequest, opts ...grpc.CallOption) (*DecryptInitResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DecryptInitResponse)
	err := c.cc.Invoke(ctx, CryptographicToken_DecryptInit_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cryptographicTokenClient) Decrypt(ctx context.Context, in *DecryptRequest, opts ...grpc.CallOption) (*DecryptResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DecryptResponse)
	err := c.cc.Invoke(ctx, CryptographicToken_Decrypt_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cryptographicTokenClient) DecryptUpdate(ctx context.Context, in *DecryptUpdateRequest, opts ...grpc.CallOption) (*DecryptUpdateResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DecryptUpdateResponse)
	err := c.cc.Invoke(ctx, CryptographicToken_DecryptUpdate_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cryptographicTokenClient) DecryptFinal(ctx context.Context, in *DecryptFinalRequest, opts ...grpc.CallOption) (*DecryptFinalResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DecryptFinalResponse)
	err := c.cc.Invoke(ctx, CryptographicToken_DecryptFinal_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cryptographicTokenClient) DecryptMessageInit(ctx context.Context, in *DecryptMessageInitRequest, opts ...grpc.CallOption) (*DecryptMessageInitResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DecryptMessageInitResponse)
	err := c.cc.Invoke(ctx, CryptographicToken_DecryptMessageInit_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cryptographicTokenClient) DecryptMessage(ctx context.Context, in *DecryptMessageRequest, opts ...grpc.CallOption) (*DecryptMessageResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DecryptMessageResponse)
	err := c.cc.Invoke(ctx, CryptographicToken_DecryptMessage_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cryptographicTokenClient) DecryptMessageBegin(ctx context.Context, in *DecryptMessageBeginRequest, opts ...grpc.CallOption) (*DecryptMessageBeginResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DecryptMessageBeginResponse)
	err := c.cc.Invoke(ctx, CryptographicToken_DecryptMessageBegin_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cryptographicTokenClient) DecryptMessageNext(ctx context.Context, in *DecryptMessageNextRequest, opts ...grpc.CallOption) (*DecryptMessageNextResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DecryptMessageNextResponse)
	err := c.cc.Invoke(ctx, CryptographicToken_DecryptMessageNext_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cryptographicTokenClient) MessageDecryptFinal(ctx context.Context, in *MessageDecryptFinalRequest, opts ...grpc.CallOption) (*MessageDecryptFinalResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(MessageDecryptFinalResponse)
	err := c.cc.Invoke(ctx, CryptographicToken_MessageDecryptFinal_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cryptographicTokenClient) DigestInit(ctx context.Context, in *DigestInitRequest, opts ...grpc.CallOption) (*DigestInitResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DigestInitResponse)
	err := c.cc.Invoke(ctx, CryptographicToken_DigestInit_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cryptographicTokenClient) Digest(ctx context.Context, in *DigestRequest, opts ...grpc.CallOption) (*DigestResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DigestResponse)
	err := c.cc.Invoke(ctx, CryptographicToken_Digest_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cryptographicTokenClient) DigestUpdate(ctx context.Context, in *DigestUpdateRequest, opts ...grpc.CallOption) (*DigestUpdateResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DigestUpdateResponse)
	err := c.cc.Invoke(ctx, CryptographicToken_DigestUpdate_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cryptographicTokenClient) DigestKey(ctx context.Context, in *DigestKeyRequest, opts ...grpc.CallOption) (*DigestKeyResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DigestKeyResponse)
	err := c.cc.Invoke(ctx, CryptographicToken_DigestKey_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cryptographicTokenClient) DigestFinal(ctx context.Context, in *DigestFinalRequest, opts ...grpc.CallOption) (*DigestFinalResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DigestFinalResponse)
	err := c.cc.Invoke(ctx, CryptographicToken_DigestFinal_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cryptographicTokenClient) SignInit(ctx context.Context, in *SignInitRequest, opts ...grpc.CallOption) (*SignInitResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SignInitResponse)
	err := c.cc.Invoke(ctx, CryptographicToken_SignInit_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cryptographicTokenClient) Sign(ctx context.Context, in *SignRequest, opts ...grpc.CallOption) (*SignResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SignResponse)
	err := c.cc.Invoke(ctx, CryptographicToken_Sign_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cryptographicTokenClient) SignUpdate(ctx context.Context, in *SignUpdateRequest, opts ...grpc.CallOption) (*SignUpdateResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SignUpdateResponse)
	err := c.cc.Invoke(ctx, CryptographicToken_SignUpdate_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cryptographicTokenClient) SignFinal(ctx context.Context, in *SignFinalRequest, opts ...grpc.CallOption) (*SignFinalResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SignFinalResponse)
	err := c.cc.Invoke(ctx, CryptographicToken_SignFinal_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cryptographicTokenClient) SignRecoverInit(ctx context.Context, in *SignRecoverInitRequest, opts ...grpc.CallOption) (*SignRecoverInitResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SignRecoverInitResponse)
	err := c.cc.Invoke(ctx, CryptographicToken_SignRecoverInit_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cryptographicTokenClient) SignRecover(ctx context.Context, in *SignRecoverRequest, opts ...grpc.CallOption) (*SignRecoverResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SignRecoverResponse)
	err := c.cc.Invoke(ctx, CryptographicToken_SignRecover_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cryptographicTokenClient) SignMessageInit(ctx context.Context, in *SignMessageInitRequest, opts ...grpc.CallOption) (*SignMessageInitResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SignMessageInitResponse)
	err := c.cc.Invoke(ctx, CryptographicToken_SignMessageInit_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cryptographicTokenClient) SignMessage(ctx context.Context, in *SignMessageRequest, opts ...grpc.CallOption) (*SignMessageResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SignMessageResponse)
	err := c.cc.Invoke(ctx, CryptographicToken_SignMessage_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cryptographicTokenClient) SignMessageBegin(ctx context.Context, in *SignMessageBeginRequest, opts ...grpc.CallOption) (*SignMessageBeginResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SignMessageBeginResponse)
	err := c.cc.Invoke(ctx, CryptographicToken_SignMessageBegin_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cryptographicTokenClient) SignMessageNext(ctx context.Context, in *SignMessageNextRequest, opts ...grpc.CallOption) (*SignMessageNextResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SignMessageNextResponse)
	err := c.cc.Invoke(ctx, CryptographicToken_SignMessageNext_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cryptographicTokenClient) SignMessageFinal(ctx context.Context, in *SignMessageFinalRequest, opts ...grpc.CallOption) (*SignMessageFinalResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SignMessageFinalResponse)
	err := c.cc.Invoke(ctx, CryptographicToken_SignMessageFinal_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cryptographicTokenClient) VerifyInit(ctx context.Context, in *VerifyInitRequest, opts ...grpc.CallOption) (*VerifyInitResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(VerifyInitResponse)
	err := c.cc.Invoke(ctx, CryptographicToken_VerifyInit_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cryptographicTokenClient) Verify(ctx context.Context, in *VerifyRequest, opts ...grpc.CallOption) (*VerifyResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(VerifyResponse)
	err := c.cc.Invoke(ctx, CryptographicToken_Verify_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cryptographicTokenClient) VerifyUpdate(ctx context.Context, in *VerifyUpdateRequest, opts ...grpc.CallOption) (*VerifyUpdateResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(VerifyUpdateResponse)
	err := c.cc.Invoke(ctx, CryptographicToken_VerifyUpdate_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cryptographicTokenClient) VerifyFinal(ctx context.Context, in *VerifyFinalRequest, opts ...grpc.CallOption) (*VerifyFinalResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(VerifyFinalResponse)
	err := c.cc.Invoke(ctx, CryptographicToken_VerifyFinal_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cryptographicTokenClient) VerifyRecoverInit(ctx context.Context, in *VerifyRecoverInitRequest, opts ...grpc.CallOption) (*VerifyRecoverInitResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(VerifyRecoverInitResponse)
	err := c.cc.Invoke(ctx, CryptographicToken_VerifyRecoverInit_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cryptographicTokenClient) VerifyRecover(ctx context.Context, in *VerifyRecoverRequest, opts ...grpc.CallOption) (*VerifyRecoverResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(VerifyRecoverResponse)
	err := c.cc.Invoke(ctx, CryptographicToken_VerifyRecover_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cryptographicTokenClient) VerifyMessageInit(ctx context.Context, in *VerifyMessageInitRequest, opts ...grpc.CallOption) (*VerifyMessageInitResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(VerifyMessageInitResponse)
	err := c.cc.Invoke(ctx, CryptographicToken_VerifyMessageInit_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cryptographicTokenClient) VerifyMessage(ctx context.Context, in *VerifyMessageRequest, opts ...grpc.CallOption) (*VerifyMessageResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(VerifyMessageResponse)
	err := c.cc.Invoke(ctx, CryptographicToken_VerifyMessage_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cryptographicTokenClient) VerifyMessageBegin(ctx context.Context, in *VerifyMessageBeginRequest, opts ...grpc.CallOption) (*VerifyMessageBeginResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(VerifyMessageBeginResponse)
	err := c.cc.Invoke(ctx, CryptographicToken_VerifyMessageBegin_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cryptographicTokenClient) VerifyMessageNext(ctx context.Context, in *VerifyMessageNextRequest, opts ...grpc.CallOption) (*VerifyMessageNextResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(VerifyMessageNextResponse)
	err := c.cc.Invoke(ctx, CryptographicToken_VerifyMessageNext_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cryptographicTokenClient) VerifyMessageFinal(ctx context.Context, in *VerifyMessageFinalRequest, opts ...grpc.CallOption) (*VerifyMessageFinalResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(VerifyMessageFinalResponse)
	err := c.cc.Invoke(ctx, CryptographicToken_VerifyMessageFinal_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cryptographicTokenClient) DigestEncryptUpdate(ctx context.Context, in *DigestEncryptUpdateRequest, opts ...grpc.CallOption) (*DigestEncryptUpdateResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DigestEncryptUpdateResponse)
	err := c.cc.Invoke(ctx, CryptographicToken_DigestEncryptUpdate_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cryptographicTokenClient) DecryptDigestUpdate(ctx context.Context, in *DecryptDigestUpdateRequest, opts ...grpc.CallOption) (*DecryptDigestUpdateResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DecryptDigestUpdateResponse)
	err := c.cc.Invoke(ctx, CryptographicToken_DecryptDigestUpdate_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cryptographicTokenClient) SignEncryptUpdate(ctx context.Context, in *SignEncryptUpdateRequest, opts ...grpc.CallOption) (*SignEncryptUpdateResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SignEncryptUpdateResponse)
	err := c.cc.Invoke(ctx, CryptographicToken_SignEncryptUpdate_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cryptographicTokenClient) DecryptVerifyUpdate(ctx context.Context, in *DecryptVerifyUpdateRequest, opts ...grpc.CallOption) (*DecryptVerifyUpdateResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DecryptVerifyUpdateResponse)
	err := c.cc.Invoke(ctx, CryptographicToken_DecryptVerifyUpdate_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cryptographicTokenClient) GenerateKey(ctx context.Context, in *GenerateKeyRequest, opts ...grpc.CallOption) (*GenerateKeyResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GenerateKeyResponse)
	err := c.cc.Invoke(ctx, CryptographicToken_GenerateKey_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cryptographicTokenClient) GenerateKeyPair(ctx context.Context, in *GenerateKeyPairRequest, opts ...grpc.CallOption) (*GenerateKeyPairResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GenerateKeyPairResponse)
	err := c.cc.Invoke(ctx, CryptographicToken_GenerateKeyPair_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cryptographicTokenClient) WrapKey(ctx context.Context, in *WrapKeyRequest, opts ...grpc.CallOption) (*WrapKeyResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(WrapKeyResponse)
	err := c.cc.Invoke(ctx, CryptographicToken_WrapKey_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cryptographicTokenClient) UnwrapKey(ctx context.Context, in *UnwrapKeyRequest, opts ...grpc.CallOption) (*UnwrapKeyResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UnwrapKeyResponse)
	err := c.cc.Invoke(ctx, CryptographicToken_UnwrapKey_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cryptographicTokenClient) DeriveKey(ctx context.Context, in *DeriveKeyRequest, opts ...grpc.CallOption) (*DeriveKeyResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DeriveKeyResponse)
	err := c.cc.Invoke(ctx, CryptographicToken_DeriveKey_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cryptographicTokenClient) SeedRandom(ctx context.Context, in *SeedRandomRequest, opts ...grpc.CallOption) (*SeedRandomResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SeedRandomResponse)
	err := c.cc.Invoke(ctx, CryptographicToken_SeedRandom_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cryptographicTokenClient) GenerateRandom(ctx context.Context, in *GenerateRandomRequest, opts ...grpc.CallOption) (*GenerateRandomResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GenerateRandomResponse)
	err := c.cc.Invoke(ctx, CryptographicToken_GenerateRandom_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cryptographicTokenClient) GetFunctionStatus(ctx context.Context, in *GetFunctionStatusRequest, opts ...grpc.CallOption) (*GetFunctionStatusResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetFunctionStatusResponse)
	err := c.cc.Invoke(ctx, CryptographicToken_GetFunctionStatus_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cryptographicTokenClient) CancelFunction(ctx context.Context, in *CancelFunctionRequest, opts ...grpc.CallOption) (*CancelFunctionResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CancelFunctionResponse)
	err := c.cc.Invoke(ctx, CryptographicToken_CancelFunction_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// CryptographicTokenServer is the server API for CryptographicToken service.
// All implementations must embed UnimplementedCryptographicTokenServer
// for forward compatibility.
type CryptographicTokenServer interface {
	Initialize(context.Context, *InitializeRequest) (*InitializeResponse, error)
	Finalize(context.Context, *FinalizeRequest) (*FinalizeResponse, error)
	GetInfo(context.Context, *GetInfoRequest) (*GetInfoResponse, error)
	GetFunctionList(context.Context, *GetFunctionListRequest) (*GetFunctionListResponse, error)
	GetInterfaceList(context.Context, *GetInterfaceListRequest) (*GetInterfaceListResponse, error)
	GetInterface(context.Context, *GetInterfaceRequest) (*GetInterfaceResponse, error)
	GetSlotList(context.Context, *GetSlotListRequest) (*GetSlotListResponse, error)
	GetSlotInfo(context.Context, *GetSlotInfoRequest) (*GetSlotInfoResponse, error)
	GetTokenInfo(context.Context, *GetTokenInfoRequest) (*GetTokenInfoResponse, error)
	WaitForSlotEvent(context.Context, *WaitForSlotEventRequest) (*WaitForSlotEventResponse, error)
	GetMechanismList(context.Context, *GetMechanismListRequest) (*GetMechanismListResponse, error)
	GetMechanismInfo(context.Context, *GetMechanismInfoRequest) (*GetMechanismInfoResponse, error)
	InitToken(context.Context, *InitTokenRequest) (*InitTokenResponse, error)
	InitPIN(context.Context, *InitPINRequest) (*InitPINResponse, error)
	SetPIN(context.Context, *SetPINRequest) (*SetPINResponse, error)
	OpenSession(context.Context, *OpenSessionRequest) (*OpenSessionResponse, error)
	CloseSession(context.Context, *CloseSessionRequest) (*CloseSessionResponse, error)
	CloseAllSessions(context.Context, *CloseAllSessionsRequest) (*CloseAllSessionsResponse, error)
	GetSessionInfo(context.Context, *GetSessionInfoRequest) (*GetSessionInfoResponse, error)
	SessionCancel(context.Context, *SessionCancelRequest) (*SessionCancelResponse, error)
	CreateObject(context.Context, *CreateObjectRequest) (*CreateObjectResponse, error)
	CopyObject(context.Context, *CopyObjectRequest) (*CopyObjectResponse, error)
	DestroyObject(context.Context, *DestroyObjectRequest) (*DestroyObjectResponse, error)
	GetObjectSize(context.Context, *GetObjectSizeRequest) (*GetObjectSizeResponse, error)
	GetAttributeValue(context.Context, *GetAttributeValueRequest) (*GetAttributeValueResponse, error)
	SetAttributeValue(context.Context, *SetAttributeValueRequest) (*SetAttributeValueResponse, error)
	FindObjectsInit(context.Context, *FindObjectsInitRequest) (*FindObjectsInitResponse, error)
	FindObjects(context.Context, *FindObjectsRequest) (*FindObjectsResponse, error)
	FindObjectsFinal(context.Context, *FindObjectsFinalRequest) (*FindObjectsFinalResponse, error)
	EncryptInit(context.Context, *EncryptInitRequest) (*EncryptInitResponse, error)
	Encrypt(context.Context, *EncryptRequest) (*EncryptResponse, error)
	EncryptUpdate(context.Context, *EncryptUpdateRequest) (*EncryptUpdateResponse, error)
	EncryptFinal(context.Context, *EncryptFinalRequest) (*EncryptFinalResponse, error)
	EncryptMessageInit(context.Context, *EncryptMessageInitRequest) (*EncryptMessageInitResponse, error)
	EncryptMessage(context.Context, *EncryptMessageRequest) (*EncryptMessageResponse, error)
	EncryptMessageBegin(context.Context, *EncryptMessageBeginRequest) (*EncryptMessageBeginResponse, error)
	EncryptMessageNext(context.Context, *EncryptMessageNextRequest) (*EncryptMessageNextResponse, error)
	EncryptMessageFinal(context.Context, *EncryptMessageFinalRequest) (*EncryptMessageFinalResponse, error)
	DecryptInit(context.Context, *DecryptInitRequest) (*DecryptInitResponse, error)
	Decrypt(context.Context, *DecryptRequest) (*DecryptResponse, error)
	DecryptUpdate(context.Context, *DecryptUpdateRequest) (*DecryptUpdateResponse, error)
	DecryptFinal(context.Context, *DecryptFinalRequest) (*DecryptFinalResponse, error)
	DecryptMessageInit(context.Context, *DecryptMessageInitRequest) (*DecryptMessageInitResponse, error)
	DecryptMessage(context.Context, *DecryptMessageRequest) (*DecryptMessageResponse, error)
	DecryptMessageBegin(context.Context, *DecryptMessageBeginRequest) (*DecryptMessageBeginResponse, error)
	DecryptMessageNext(context.Context, *DecryptMessageNextRequest) (*DecryptMessageNextResponse, error)
	MessageDecryptFinal(context.Context, *MessageDecryptFinalRequest) (*MessageDecryptFinalResponse, error)
	DigestInit(context.Context, *DigestInitRequest) (*DigestInitResponse, error)
	Digest(context.Context, *DigestRequest) (*DigestResponse, error)
	DigestUpdate(context.Context, *DigestUpdateRequest) (*DigestUpdateResponse, error)
	DigestKey(context.Context, *DigestKeyRequest) (*DigestKeyResponse, error)
	DigestFinal(context.Context, *DigestFinalRequest) (*DigestFinalResponse, error)
	SignInit(context.Context, *SignInitRequest) (*SignInitResponse, error)
	Sign(context.Context, *SignRequest) (*SignResponse, error)
	SignUpdate(context.Context, *SignUpdateRequest) (*SignUpdateResponse, error)
	SignFinal(context.Context, *SignFinalRequest) (*SignFinalResponse, error)
	SignRecoverInit(context.Context, *SignRecoverInitRequest) (*SignRecoverInitResponse, error)
	SignRecover(context.Context, *SignRecoverRequest) (*SignRecoverResponse, error)
	SignMessageInit(context.Context, *SignMessageInitRequest) (*SignMessageInitResponse, error)
	SignMessage(context.Context, *SignMessageRequest) (*SignMessageResponse, error)
	SignMessageBegin(context.Context, *SignMessageBeginRequest) (*SignMessageBeginResponse, error)
	SignMessageNext(context.Context, *SignMessageNextRequest) (*SignMessageNextResponse, error)
	SignMessageFinal(context.Context, *SignMessageFinalRequest) (*SignMessageFinalResponse, error)
	VerifyInit(context.Context, *VerifyInitRequest) (*VerifyInitResponse, error)
	Verify(context.Context, *VerifyRequest) (*VerifyResponse, error)
	VerifyUpdate(context.Context, *VerifyUpdateRequest) (*VerifyUpdateResponse, error)
	VerifyFinal(context.Context, *VerifyFinalRequest) (*VerifyFinalResponse, error)
	VerifyRecoverInit(context.Context, *VerifyRecoverInitRequest) (*VerifyRecoverInitResponse, error)
	VerifyRecover(context.Context, *VerifyRecoverRequest) (*VerifyRecoverResponse, error)
	VerifyMessageInit(context.Context, *VerifyMessageInitRequest) (*VerifyMessageInitResponse, error)
	VerifyMessage(context.Context, *VerifyMessageRequest) (*VerifyMessageResponse, error)
	VerifyMessageBegin(context.Context, *VerifyMessageBeginRequest) (*VerifyMessageBeginResponse, error)
	VerifyMessageNext(context.Context, *VerifyMessageNextRequest) (*VerifyMessageNextResponse, error)
	VerifyMessageFinal(context.Context, *VerifyMessageFinalRequest) (*VerifyMessageFinalResponse, error)
	DigestEncryptUpdate(context.Context, *DigestEncryptUpdateRequest) (*DigestEncryptUpdateResponse, error)
	DecryptDigestUpdate(context.Context, *DecryptDigestUpdateRequest) (*DecryptDigestUpdateResponse, error)
	SignEncryptUpdate(context.Context, *SignEncryptUpdateRequest) (*SignEncryptUpdateResponse, error)
	DecryptVerifyUpdate(context.Context, *DecryptVerifyUpdateRequest) (*DecryptVerifyUpdateResponse, error)
	GenerateKey(context.Context, *GenerateKeyRequest) (*GenerateKeyResponse, error)
	GenerateKeyPair(context.Context, *GenerateKeyPairRequest) (*GenerateKeyPairResponse, error)
	WrapKey(context.Context, *WrapKeyRequest) (*WrapKeyResponse, error)
	UnwrapKey(context.Context, *UnwrapKeyRequest) (*UnwrapKeyResponse, error)
	DeriveKey(context.Context, *DeriveKeyRequest) (*DeriveKeyResponse, error)
	SeedRandom(context.Context, *SeedRandomRequest) (*SeedRandomResponse, error)
	GenerateRandom(context.Context, *GenerateRandomRequest) (*GenerateRandomResponse, error)
	GetFunctionStatus(context.Context, *GetFunctionStatusRequest) (*GetFunctionStatusResponse, error)
	CancelFunction(context.Context, *CancelFunctionRequest) (*CancelFunctionResponse, error)
	mustEmbedUnimplementedCryptographicTokenServer()
}

// UnimplementedCryptographicTokenServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedCryptographicTokenServer struct{}

func (UnimplementedCryptographicTokenServer) Initialize(context.Context, *InitializeRequest) (*InitializeResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Initialize not implemented")
}
func (UnimplementedCryptographicTokenServer) Finalize(context.Context, *FinalizeRequest) (*FinalizeResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Finalize not implemented")
}
func (UnimplementedCryptographicTokenServer) GetInfo(context.Context, *GetInfoRequest) (*GetInfoResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetInfo not implemented")
}
func (UnimplementedCryptographicTokenServer) GetFunctionList(context.Context, *GetFunctionListRequest) (*GetFunctionListResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetFunctionList not implemented")
}
func (UnimplementedCryptographicTokenServer) GetInterfaceList(context.Context, *GetInterfaceListRequest) (*GetInterfaceListResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetInterfaceList not implemented")
}
func (UnimplementedCryptographicTokenServer) GetInterface(context.Context, *GetInterfaceRequest) (*GetInterfaceResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetInterface not implemented")
}
func (UnimplementedCryptographicTokenServer) GetSlotList(context.Context, *GetSlotListRequest) (*GetSlotListResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetSlotList not implemented")
}
func (UnimplementedCryptographicTokenServer) GetSlotInfo(context.Context, *GetSlotInfoRequest) (*GetSlotInfoResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetSlotInfo not implemented")
}
func (UnimplementedCryptographicTokenServer) GetTokenInfo(context.Context, *GetTokenInfoRequest) (*GetTokenInfoResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetTokenInfo not implemented")
}
func (UnimplementedCryptographicTokenServer) WaitForSlotEvent(context.Context, *WaitForSlotEventRequest) (*WaitForSlotEventResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method WaitForSlotEvent not implemented")
}
func (UnimplementedCryptographicTokenServer) GetMechanismList(context.Context, *GetMechanismListRequest) (*GetMechanismListResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetMechanismList not implemented")
}
func (UnimplementedCryptographicTokenServer) GetMechanismInfo(context.Context, *GetMechanismInfoRequest) (*GetMechanismInfoResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetMechanismInfo not implemented")
}
func (UnimplementedCryptographicTokenServer) InitToken(context.Context, *InitTokenRequest) (*InitTokenResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method InitToken not implemented")
}
func (UnimplementedCryptographicTokenServer) InitPIN(context.Context, *InitPINRequest) (*InitPINResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method InitPIN not implemented")
}
func (UnimplementedCryptographicTokenServer) SetPIN(context.Context, *SetPINRequest) (*SetPINResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetPIN not implemented")
}
func (UnimplementedCryptographicTokenServer) OpenSession(context.Context, *OpenSessionRequest) (*OpenSessionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method OpenSession not implemented")
}
func (UnimplementedCryptographicTokenServer) CloseSession(context.Context, *CloseSessionRequest) (*CloseSessionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CloseSession not implemented")
}
func (UnimplementedCryptographicTokenServer) CloseAllSessions(context.Context, *CloseAllSessionsRequest) (*CloseAllSessionsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CloseAllSessions not implemented")
}
func (UnimplementedCryptographicTokenServer) GetSessionInfo(context.Context, *GetSessionInfoRequest) (*GetSessionInfoResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetSessionInfo not implemented")
}
func (UnimplementedCryptographicTokenServer) SessionCancel(context.Context, *SessionCancelRequest) (*SessionCancelResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SessionCancel not implemented")
}
func (UnimplementedCryptographicTokenServer) CreateObject(context.Context, *CreateObjectRequest) (*CreateObjectResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateObject not implemented")
}
func (UnimplementedCryptographicTokenServer) CopyObject(context.Context, *CopyObjectRequest) (*CopyObjectResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CopyObject not implemented")
}
func (UnimplementedCryptographicTokenServer) DestroyObject(context.Context, *DestroyObjectRequest) (*DestroyObjectResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DestroyObject not implemented")
}
func (UnimplementedCryptographicTokenServer) GetObjectSize(context.Context, *GetObjectSizeRequest) (*GetObjectSizeResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetObjectSize not implemented")
}
func (UnimplementedCryptographicTokenServer) GetAttributeValue(context.Context, *GetAttributeValueRequest) (*GetAttributeValueResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetAttributeValue not implemented")
}
func (UnimplementedCryptographicTokenServer) SetAttributeValue(context.Context, *SetAttributeValueRequest) (*SetAttributeValueResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetAttributeValue not implemented")
}
func (UnimplementedCryptographicTokenServer) FindObjectsInit(context.Context, *FindObjectsInitRequest) (*FindObjectsInitResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method FindObjectsInit not implemented")
}
func (UnimplementedCryptographicTokenServer) FindObjects(context.Context, *FindObjectsRequest) (*FindObjectsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method FindObjects not implemented")
}
func (UnimplementedCryptographicTokenServer) FindObjectsFinal(context.Context, *FindObjectsFinalRequest) (*FindObjectsFinalResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method FindObjectsFinal not implemented")
}
func (UnimplementedCryptographicTokenServer) EncryptInit(context.Context, *EncryptInitRequest) (*EncryptInitResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method EncryptInit not implemented")
}
func (UnimplementedCryptographicTokenServer) Encrypt(context.Context, *EncryptRequest) (*EncryptResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Encrypt not implemented")
}
func (UnimplementedCryptographicTokenServer) EncryptUpdate(context.Context, *EncryptUpdateRequest) (*EncryptUpdateResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method EncryptUpdate not implemented")
}
func (UnimplementedCryptographicTokenServer) EncryptFinal(context.Context, *EncryptFinalRequest) (*EncryptFinalResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method EncryptFinal not implemented")
}
func (UnimplementedCryptographicTokenServer) EncryptMessageInit(context.Context, *EncryptMessageInitRequest) (*EncryptMessageInitResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method EncryptMessageInit not implemented")
}
func (UnimplementedCryptographicTokenServer) EncryptMessage(context.Context, *EncryptMessageRequest) (*EncryptMessageResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method EncryptMessage not implemented")
}
func (UnimplementedCryptographicTokenServer) EncryptMessageBegin(context.Context, *EncryptMessageBeginRequest) (*EncryptMessageBeginResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method EncryptMessageBegin not implemented")
}
func (UnimplementedCryptographicTokenServer) EncryptMessageNext(context.Context, *EncryptMessageNextRequest) (*EncryptMessageNextResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method EncryptMessageNext not implemented")
}
func (UnimplementedCryptographicTokenServer) EncryptMessageFinal(context.Context, *EncryptMessageFinalRequest) (*EncryptMessageFinalResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method EncryptMessageFinal not implemented")
}
func (UnimplementedCryptographicTokenServer) DecryptInit(context.Context, *DecryptInitRequest) (*DecryptInitResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DecryptInit not implemented")
}
func (UnimplementedCryptographicTokenServer) Decrypt(context.Context, *DecryptRequest) (*DecryptResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Decrypt not implemented")
}
func (UnimplementedCryptographicTokenServer) DecryptUpdate(context.Context, *DecryptUpdateRequest) (*DecryptUpdateResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DecryptUpdate not implemented")
}
func (UnimplementedCryptographicTokenServer) DecryptFinal(context.Context, *DecryptFinalRequest) (*DecryptFinalResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DecryptFinal not implemented")
}
func (UnimplementedCryptographicTokenServer) DecryptMessageInit(context.Context, *DecryptMessageInitRequest) (*DecryptMessageInitResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DecryptMessageInit not implemented")
}
func (UnimplementedCryptographicTokenServer) DecryptMessage(context.Context, *DecryptMessageRequest) (*DecryptMessageResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DecryptMessage not implemented")
}
func (UnimplementedCryptographicTokenServer) DecryptMessageBegin(context.Context, *DecryptMessageBeginRequest) (*DecryptMessageBeginResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DecryptMessageBegin not implemented")
}
func (UnimplementedCryptographicTokenServer) DecryptMessageNext(context.Context, *DecryptMessageNextRequest) (*DecryptMessageNextResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DecryptMessageNext not implemented")
}
func (UnimplementedCryptographicTokenServer) MessageDecryptFinal(context.Context, *MessageDecryptFinalRequest) (*MessageDecryptFinalResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method MessageDecryptFinal not implemented")
}
func (UnimplementedCryptographicTokenServer) DigestInit(context.Context, *DigestInitRequest) (*DigestInitResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DigestInit not implemented")
}
func (UnimplementedCryptographicTokenServer) Digest(context.Context, *DigestRequest) (*DigestResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Digest not implemented")
}
func (UnimplementedCryptographicTokenServer) DigestUpdate(context.Context, *DigestUpdateRequest) (*DigestUpdateResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DigestUpdate not implemented")
}
func (UnimplementedCryptographicTokenServer) DigestKey(context.Context, *DigestKeyRequest) (*DigestKeyResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DigestKey not implemented")
}
func (UnimplementedCryptographicTokenServer) DigestFinal(context.Context, *DigestFinalRequest) (*DigestFinalResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DigestFinal not implemented")
}
func (UnimplementedCryptographicTokenServer) SignInit(context.Context, *SignInitRequest) (*SignInitResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SignInit not implemented")
}
func (UnimplementedCryptographicTokenServer) Sign(context.Context, *SignRequest) (*SignResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Sign not implemented")
}
func (UnimplementedCryptographicTokenServer) SignUpdate(context.Context, *SignUpdateRequest) (*SignUpdateResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SignUpdate not implemented")
}
func (UnimplementedCryptographicTokenServer) SignFinal(context.Context, *SignFinalRequest) (*SignFinalResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SignFinal not implemented")
}
func (UnimplementedCryptographicTokenServer) SignRecoverInit(context.Context, *SignRecoverInitRequest) (*SignRecoverInitResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SignRecoverInit not implemented")
}
func (UnimplementedCryptographicTokenServer) SignRecover(context.Context, *SignRecoverRequest) (*SignRecoverResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SignRecover not implemented")
}
func (UnimplementedCryptographicTokenServer) SignMessageInit(context.Context, *SignMessageInitRequest) (*SignMessageInitResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SignMessageInit not implemented")
}
func (UnimplementedCryptographicTokenServer) SignMessage(context.Context, *SignMessageRequest) (*SignMessageResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SignMessage not implemented")
}
func (UnimplementedCryptographicTokenServer) SignMessageBegin(context.Context, *SignMessageBeginRequest) (*SignMessageBeginResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SignMessageBegin not implemented")
}
func (UnimplementedCryptographicTokenServer) SignMessageNext(context.Context, *SignMessageNextRequest) (*SignMessageNextResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SignMessageNext not implemented")
}
func (UnimplementedCryptographicTokenServer) SignMessageFinal(context.Context, *SignMessageFinalRequest) (*SignMessageFinalResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SignMessageFinal not implemented")
}
func (UnimplementedCryptographicTokenServer) VerifyInit(context.Context, *VerifyInitRequest) (*VerifyInitResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method VerifyInit not implemented")
}
func (UnimplementedCryptographicTokenServer) Verify(context.Context, *VerifyRequest) (*VerifyResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Verify not implemented")
}
func (UnimplementedCryptographicTokenServer) VerifyUpdate(context.Context, *VerifyUpdateRequest) (*VerifyUpdateResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method VerifyUpdate not implemented")
}
func (UnimplementedCryptographicTokenServer) VerifyFinal(context.Context, *VerifyFinalRequest) (*VerifyFinalResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method VerifyFinal not implemented")
}
func (UnimplementedCryptographicTokenServer) VerifyRecoverInit(context.Context, *VerifyRecoverInitRequest) (*VerifyRecoverInitResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method VerifyRecoverInit not implemented")
}
func (UnimplementedCryptographicTokenServer) VerifyRecover(context.Context, *VerifyRecoverRequest) (*VerifyRecoverResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method VerifyRecover not implemented")
}
func (UnimplementedCryptographicTokenServer) VerifyMessageInit(context.Context, *VerifyMessageInitRequest) (*VerifyMessageInitResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method VerifyMessageInit not implemented")
}
func (UnimplementedCryptographicTokenServer) VerifyMessage(context.Context, *VerifyMessageRequest) (*VerifyMessageResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method VerifyMessage not implemented")
}
func (UnimplementedCryptographicTokenServer) VerifyMessageBegin(context.Context, *VerifyMessageBeginRequest) (*VerifyMessageBeginResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method VerifyMessageBegin not implemented")
}
func (UnimplementedCryptographicTokenServer) VerifyMessageNext(context.Context, *VerifyMessageNextRequest) (*VerifyMessageNextResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method VerifyMessageNext not implemented")
}
func (UnimplementedCryptographicTokenServer) VerifyMessageFinal(context.Context, *VerifyMessageFinalRequest) (*VerifyMessageFinalResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method VerifyMessageFinal not implemented")
}
func (UnimplementedCryptographicTokenServer) DigestEncryptUpdate(context.Context, *DigestEncryptUpdateRequest) (*DigestEncryptUpdateResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DigestEncryptUpdate not implemented")
}
func (UnimplementedCryptographicTokenServer) DecryptDigestUpdate(context.Context, *DecryptDigestUpdateRequest) (*DecryptDigestUpdateResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DecryptDigestUpdate not implemented")
}
func (UnimplementedCryptographicTokenServer) SignEncryptUpdate(context.Context, *SignEncryptUpdateRequest) (*SignEncryptUpdateResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SignEncryptUpdate not implemented")
}
func (UnimplementedCryptographicTokenServer) DecryptVerifyUpdate(context.Context, *DecryptVerifyUpdateRequest) (*DecryptVerifyUpdateResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DecryptVerifyUpdate not implemented")
}
func (UnimplementedCryptographicTokenServer) GenerateKey(context.Context, *GenerateKeyRequest) (*GenerateKeyResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GenerateKey not implemented")
}
func (UnimplementedCryptographicTokenServer) GenerateKeyPair(context.Context, *GenerateKeyPairRequest) (*GenerateKeyPairResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GenerateKeyPair not implemented")
}
func (UnimplementedCryptographicTokenServer) WrapKey(context.Context, *WrapKeyRequest) (*WrapKeyResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method WrapKey not implemented")
}
func (UnimplementedCryptographicTokenServer) UnwrapKey(context.Context, *UnwrapKeyRequest) (*UnwrapKeyResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UnwrapKey not implemented")
}
func (UnimplementedCryptographicTokenServer) DeriveKey(context.Context, *DeriveKeyRequest) (*DeriveKeyResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeriveKey not implemented")
}
func (UnimplementedCryptographicTokenServer) SeedRandom(context.Context, *SeedRandomRequest) (*SeedRandomResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SeedRandom not implemented")
}
func (UnimplementedCryptographicTokenServer) GenerateRandom(context.Context, *GenerateRandomRequest) (*GenerateRandomResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GenerateRandom not implemented")
}
func (UnimplementedCryptographicTokenServer) GetFunctionStatus(context.Context, *GetFunctionStatusRequest) (*GetFunctionStatusResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetFunctionStatus not implemented")
}
func (UnimplementedCryptographicTokenServer) CancelFunction(context.Context, *CancelFunctionRequest) (*CancelFunctionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CancelFunction not implemented")
}
func (UnimplementedCryptographicTokenServer) mustEmbedUnimplementedCryptographicTokenServer() {}
func (UnimplementedCryptographicTokenServer) testEmbeddedByValue()                            {}

// UnsafeCryptographicTokenServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to CryptographicTokenServer will
// result in compilation errors.
type UnsafeCryptographicTokenServer interface {
	mustEmbedUnimplementedCryptographicTokenServer()
}

func RegisterCryptographicTokenServer(s grpc.ServiceRegistrar, srv CryptographicTokenServer) {
	// If the following call pancis, it indicates UnimplementedCryptographicTokenServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&CryptographicToken_ServiceDesc, srv)
}

func _CryptographicToken_Initialize_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InitializeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CryptographicTokenServer).Initialize(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CryptographicToken_Initialize_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CryptographicTokenServer).Initialize(ctx, req.(*InitializeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CryptographicToken_Finalize_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FinalizeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CryptographicTokenServer).Finalize(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CryptographicToken_Finalize_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CryptographicTokenServer).Finalize(ctx, req.(*FinalizeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CryptographicToken_GetInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetInfoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CryptographicTokenServer).GetInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CryptographicToken_GetInfo_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CryptographicTokenServer).GetInfo(ctx, req.(*GetInfoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CryptographicToken_GetFunctionList_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetFunctionListRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CryptographicTokenServer).GetFunctionList(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CryptographicToken_GetFunctionList_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CryptographicTokenServer).GetFunctionList(ctx, req.(*GetFunctionListRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CryptographicToken_GetInterfaceList_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetInterfaceListRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CryptographicTokenServer).GetInterfaceList(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CryptographicToken_GetInterfaceList_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CryptographicTokenServer).GetInterfaceList(ctx, req.(*GetInterfaceListRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CryptographicToken_GetInterface_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetInterfaceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CryptographicTokenServer).GetInterface(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CryptographicToken_GetInterface_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CryptographicTokenServer).GetInterface(ctx, req.(*GetInterfaceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CryptographicToken_GetSlotList_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetSlotListRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CryptographicTokenServer).GetSlotList(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CryptographicToken_GetSlotList_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CryptographicTokenServer).GetSlotList(ctx, req.(*GetSlotListRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CryptographicToken_GetSlotInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetSlotInfoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CryptographicTokenServer).GetSlotInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CryptographicToken_GetSlotInfo_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CryptographicTokenServer).GetSlotInfo(ctx, req.(*GetSlotInfoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CryptographicToken_GetTokenInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetTokenInfoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CryptographicTokenServer).GetTokenInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CryptographicToken_GetTokenInfo_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CryptographicTokenServer).GetTokenInfo(ctx, req.(*GetTokenInfoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CryptographicToken_WaitForSlotEvent_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(WaitForSlotEventRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CryptographicTokenServer).WaitForSlotEvent(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CryptographicToken_WaitForSlotEvent_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CryptographicTokenServer).WaitForSlotEvent(ctx, req.(*WaitForSlotEventRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CryptographicToken_GetMechanismList_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetMechanismListRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CryptographicTokenServer).GetMechanismList(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CryptographicToken_GetMechanismList_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CryptographicTokenServer).GetMechanismList(ctx, req.(*GetMechanismListRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CryptographicToken_GetMechanismInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetMechanismInfoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CryptographicTokenServer).GetMechanismInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CryptographicToken_GetMechanismInfo_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CryptographicTokenServer).GetMechanismInfo(ctx, req.(*GetMechanismInfoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CryptographicToken_InitToken_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InitTokenRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CryptographicTokenServer).InitToken(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CryptographicToken_InitToken_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CryptographicTokenServer).InitToken(ctx, req.(*InitTokenRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CryptographicToken_InitPIN_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InitPINRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CryptographicTokenServer).InitPIN(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CryptographicToken_InitPIN_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CryptographicTokenServer).InitPIN(ctx, req.(*InitPINRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CryptographicToken_SetPIN_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetPINRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CryptographicTokenServer).SetPIN(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CryptographicToken_SetPIN_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CryptographicTokenServer).SetPIN(ctx, req.(*SetPINRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CryptographicToken_OpenSession_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(OpenSessionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CryptographicTokenServer).OpenSession(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CryptographicToken_OpenSession_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CryptographicTokenServer).OpenSession(ctx, req.(*OpenSessionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CryptographicToken_CloseSession_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CloseSessionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CryptographicTokenServer).CloseSession(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CryptographicToken_CloseSession_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CryptographicTokenServer).CloseSession(ctx, req.(*CloseSessionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CryptographicToken_CloseAllSessions_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CloseAllSessionsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CryptographicTokenServer).CloseAllSessions(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CryptographicToken_CloseAllSessions_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CryptographicTokenServer).CloseAllSessions(ctx, req.(*CloseAllSessionsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CryptographicToken_GetSessionInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetSessionInfoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CryptographicTokenServer).GetSessionInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CryptographicToken_GetSessionInfo_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CryptographicTokenServer).GetSessionInfo(ctx, req.(*GetSessionInfoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CryptographicToken_SessionCancel_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SessionCancelRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CryptographicTokenServer).SessionCancel(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CryptographicToken_SessionCancel_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CryptographicTokenServer).SessionCancel(ctx, req.(*SessionCancelRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CryptographicToken_CreateObject_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateObjectRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CryptographicTokenServer).CreateObject(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CryptographicToken_CreateObject_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CryptographicTokenServer).CreateObject(ctx, req.(*CreateObjectRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CryptographicToken_CopyObject_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CopyObjectRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CryptographicTokenServer).CopyObject(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CryptographicToken_CopyObject_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CryptographicTokenServer).CopyObject(ctx, req.(*CopyObjectRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CryptographicToken_DestroyObject_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DestroyObjectRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CryptographicTokenServer).DestroyObject(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CryptographicToken_DestroyObject_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CryptographicTokenServer).DestroyObject(ctx, req.(*DestroyObjectRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CryptographicToken_GetObjectSize_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetObjectSizeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CryptographicTokenServer).GetObjectSize(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CryptographicToken_GetObjectSize_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CryptographicTokenServer).GetObjectSize(ctx, req.(*GetObjectSizeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CryptographicToken_GetAttributeValue_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetAttributeValueRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CryptographicTokenServer).GetAttributeValue(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CryptographicToken_GetAttributeValue_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CryptographicTokenServer).GetAttributeValue(ctx, req.(*GetAttributeValueRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CryptographicToken_SetAttributeValue_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetAttributeValueRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CryptographicTokenServer).SetAttributeValue(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CryptographicToken_SetAttributeValue_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CryptographicTokenServer).SetAttributeValue(ctx, req.(*SetAttributeValueRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CryptographicToken_FindObjectsInit_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FindObjectsInitRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CryptographicTokenServer).FindObjectsInit(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CryptographicToken_FindObjectsInit_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CryptographicTokenServer).FindObjectsInit(ctx, req.(*FindObjectsInitRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CryptographicToken_FindObjects_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FindObjectsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CryptographicTokenServer).FindObjects(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CryptographicToken_FindObjects_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CryptographicTokenServer).FindObjects(ctx, req.(*FindObjectsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CryptographicToken_FindObjectsFinal_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FindObjectsFinalRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CryptographicTokenServer).FindObjectsFinal(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CryptographicToken_FindObjectsFinal_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CryptographicTokenServer).FindObjectsFinal(ctx, req.(*FindObjectsFinalRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CryptographicToken_EncryptInit_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EncryptInitRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CryptographicTokenServer).EncryptInit(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CryptographicToken_EncryptInit_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CryptographicTokenServer).EncryptInit(ctx, req.(*EncryptInitRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CryptographicToken_Encrypt_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EncryptRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CryptographicTokenServer).Encrypt(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CryptographicToken_Encrypt_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CryptographicTokenServer).Encrypt(ctx, req.(*EncryptRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CryptographicToken_EncryptUpdate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EncryptUpdateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CryptographicTokenServer).EncryptUpdate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CryptographicToken_EncryptUpdate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CryptographicTokenServer).EncryptUpdate(ctx, req.(*EncryptUpdateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CryptographicToken_EncryptFinal_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EncryptFinalRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CryptographicTokenServer).EncryptFinal(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CryptographicToken_EncryptFinal_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CryptographicTokenServer).EncryptFinal(ctx, req.(*EncryptFinalRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CryptographicToken_EncryptMessageInit_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EncryptMessageInitRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CryptographicTokenServer).EncryptMessageInit(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CryptographicToken_EncryptMessageInit_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CryptographicTokenServer).EncryptMessageInit(ctx, req.(*EncryptMessageInitRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CryptographicToken_EncryptMessage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EncryptMessageRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CryptographicTokenServer).EncryptMessage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CryptographicToken_EncryptMessage_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CryptographicTokenServer).EncryptMessage(ctx, req.(*EncryptMessageRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CryptographicToken_EncryptMessageBegin_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EncryptMessageBeginRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CryptographicTokenServer).EncryptMessageBegin(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CryptographicToken_EncryptMessageBegin_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CryptographicTokenServer).EncryptMessageBegin(ctx, req.(*EncryptMessageBeginRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CryptographicToken_EncryptMessageNext_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EncryptMessageNextRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CryptographicTokenServer).EncryptMessageNext(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CryptographicToken_EncryptMessageNext_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CryptographicTokenServer).EncryptMessageNext(ctx, req.(*EncryptMessageNextRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CryptographicToken_EncryptMessageFinal_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EncryptMessageFinalRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CryptographicTokenServer).EncryptMessageFinal(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CryptographicToken_EncryptMessageFinal_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CryptographicTokenServer).EncryptMessageFinal(ctx, req.(*EncryptMessageFinalRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CryptographicToken_DecryptInit_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DecryptInitRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CryptographicTokenServer).DecryptInit(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CryptographicToken_DecryptInit_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CryptographicTokenServer).DecryptInit(ctx, req.(*DecryptInitRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CryptographicToken_Decrypt_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DecryptRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CryptographicTokenServer).Decrypt(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CryptographicToken_Decrypt_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CryptographicTokenServer).Decrypt(ctx, req.(*DecryptRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CryptographicToken_DecryptUpdate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DecryptUpdateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CryptographicTokenServer).DecryptUpdate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CryptographicToken_DecryptUpdate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CryptographicTokenServer).DecryptUpdate(ctx, req.(*DecryptUpdateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CryptographicToken_DecryptFinal_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DecryptFinalRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CryptographicTokenServer).DecryptFinal(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CryptographicToken_DecryptFinal_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CryptographicTokenServer).DecryptFinal(ctx, req.(*DecryptFinalRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CryptographicToken_DecryptMessageInit_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DecryptMessageInitRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CryptographicTokenServer).DecryptMessageInit(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CryptographicToken_DecryptMessageInit_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CryptographicTokenServer).DecryptMessageInit(ctx, req.(*DecryptMessageInitRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CryptographicToken_DecryptMessage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DecryptMessageRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CryptographicTokenServer).DecryptMessage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CryptographicToken_DecryptMessage_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CryptographicTokenServer).DecryptMessage(ctx, req.(*DecryptMessageRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CryptographicToken_DecryptMessageBegin_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DecryptMessageBeginRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CryptographicTokenServer).DecryptMessageBegin(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CryptographicToken_DecryptMessageBegin_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CryptographicTokenServer).DecryptMessageBegin(ctx, req.(*DecryptMessageBeginRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CryptographicToken_DecryptMessageNext_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DecryptMessageNextRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CryptographicTokenServer).DecryptMessageNext(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CryptographicToken_DecryptMessageNext_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CryptographicTokenServer).DecryptMessageNext(ctx, req.(*DecryptMessageNextRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CryptographicToken_MessageDecryptFinal_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MessageDecryptFinalRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CryptographicTokenServer).MessageDecryptFinal(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CryptographicToken_MessageDecryptFinal_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CryptographicTokenServer).MessageDecryptFinal(ctx, req.(*MessageDecryptFinalRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CryptographicToken_DigestInit_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DigestInitRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CryptographicTokenServer).DigestInit(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CryptographicToken_DigestInit_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CryptographicTokenServer).DigestInit(ctx, req.(*DigestInitRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CryptographicToken_Digest_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DigestRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CryptographicTokenServer).Digest(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CryptographicToken_Digest_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CryptographicTokenServer).Digest(ctx, req.(*DigestRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CryptographicToken_DigestUpdate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DigestUpdateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CryptographicTokenServer).DigestUpdate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CryptographicToken_DigestUpdate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CryptographicTokenServer).DigestUpdate(ctx, req.(*DigestUpdateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CryptographicToken_DigestKey_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DigestKeyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CryptographicTokenServer).DigestKey(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CryptographicToken_DigestKey_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CryptographicTokenServer).DigestKey(ctx, req.(*DigestKeyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CryptographicToken_DigestFinal_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DigestFinalRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CryptographicTokenServer).DigestFinal(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CryptographicToken_DigestFinal_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CryptographicTokenServer).DigestFinal(ctx, req.(*DigestFinalRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CryptographicToken_SignInit_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SignInitRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CryptographicTokenServer).SignInit(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CryptographicToken_SignInit_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CryptographicTokenServer).SignInit(ctx, req.(*SignInitRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CryptographicToken_Sign_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SignRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CryptographicTokenServer).Sign(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CryptographicToken_Sign_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CryptographicTokenServer).Sign(ctx, req.(*SignRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CryptographicToken_SignUpdate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SignUpdateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CryptographicTokenServer).SignUpdate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CryptographicToken_SignUpdate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CryptographicTokenServer).SignUpdate(ctx, req.(*SignUpdateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CryptographicToken_SignFinal_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SignFinalRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CryptographicTokenServer).SignFinal(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CryptographicToken_SignFinal_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CryptographicTokenServer).SignFinal(ctx, req.(*SignFinalRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CryptographicToken_SignRecoverInit_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SignRecoverInitRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CryptographicTokenServer).SignRecoverInit(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CryptographicToken_SignRecoverInit_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CryptographicTokenServer).SignRecoverInit(ctx, req.(*SignRecoverInitRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CryptographicToken_SignRecover_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SignRecoverRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CryptographicTokenServer).SignRecover(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CryptographicToken_SignRecover_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CryptographicTokenServer).SignRecover(ctx, req.(*SignRecoverRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CryptographicToken_SignMessageInit_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SignMessageInitRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CryptographicTokenServer).SignMessageInit(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CryptographicToken_SignMessageInit_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CryptographicTokenServer).SignMessageInit(ctx, req.(*SignMessageInitRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CryptographicToken_SignMessage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SignMessageRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CryptographicTokenServer).SignMessage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CryptographicToken_SignMessage_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CryptographicTokenServer).SignMessage(ctx, req.(*SignMessageRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CryptographicToken_SignMessageBegin_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SignMessageBeginRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CryptographicTokenServer).SignMessageBegin(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CryptographicToken_SignMessageBegin_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CryptographicTokenServer).SignMessageBegin(ctx, req.(*SignMessageBeginRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CryptographicToken_SignMessageNext_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SignMessageNextRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CryptographicTokenServer).SignMessageNext(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CryptographicToken_SignMessageNext_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CryptographicTokenServer).SignMessageNext(ctx, req.(*SignMessageNextRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CryptographicToken_SignMessageFinal_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SignMessageFinalRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CryptographicTokenServer).SignMessageFinal(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CryptographicToken_SignMessageFinal_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CryptographicTokenServer).SignMessageFinal(ctx, req.(*SignMessageFinalRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CryptographicToken_VerifyInit_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(VerifyInitRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CryptographicTokenServer).VerifyInit(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CryptographicToken_VerifyInit_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CryptographicTokenServer).VerifyInit(ctx, req.(*VerifyInitRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CryptographicToken_Verify_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(VerifyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CryptographicTokenServer).Verify(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CryptographicToken_Verify_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CryptographicTokenServer).Verify(ctx, req.(*VerifyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CryptographicToken_VerifyUpdate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(VerifyUpdateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CryptographicTokenServer).VerifyUpdate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CryptographicToken_VerifyUpdate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CryptographicTokenServer).VerifyUpdate(ctx, req.(*VerifyUpdateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CryptographicToken_VerifyFinal_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(VerifyFinalRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CryptographicTokenServer).VerifyFinal(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CryptographicToken_VerifyFinal_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CryptographicTokenServer).VerifyFinal(ctx, req.(*VerifyFinalRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CryptographicToken_VerifyRecoverInit_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(VerifyRecoverInitRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CryptographicTokenServer).VerifyRecoverInit(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CryptographicToken_VerifyRecoverInit_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CryptographicTokenServer).VerifyRecoverInit(ctx, req.(*VerifyRecoverInitRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CryptographicToken_VerifyRecover_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(VerifyRecoverRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CryptographicTokenServer).VerifyRecover(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CryptographicToken_VerifyRecover_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CryptographicTokenServer).VerifyRecover(ctx, req.(*VerifyRecoverRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CryptographicToken_VerifyMessageInit_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(VerifyMessageInitRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CryptographicTokenServer).VerifyMessageInit(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CryptographicToken_VerifyMessageInit_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CryptographicTokenServer).VerifyMessageInit(ctx, req.(*VerifyMessageInitRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CryptographicToken_VerifyMessage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(VerifyMessageRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CryptographicTokenServer).VerifyMessage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CryptographicToken_VerifyMessage_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CryptographicTokenServer).VerifyMessage(ctx, req.(*VerifyMessageRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CryptographicToken_VerifyMessageBegin_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(VerifyMessageBeginRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CryptographicTokenServer).VerifyMessageBegin(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CryptographicToken_VerifyMessageBegin_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CryptographicTokenServer).VerifyMessageBegin(ctx, req.(*VerifyMessageBeginRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CryptographicToken_VerifyMessageNext_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(VerifyMessageNextRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CryptographicTokenServer).VerifyMessageNext(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CryptographicToken_VerifyMessageNext_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CryptographicTokenServer).VerifyMessageNext(ctx, req.(*VerifyMessageNextRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CryptographicToken_VerifyMessageFinal_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(VerifyMessageFinalRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CryptographicTokenServer).VerifyMessageFinal(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CryptographicToken_VerifyMessageFinal_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CryptographicTokenServer).VerifyMessageFinal(ctx, req.(*VerifyMessageFinalRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CryptographicToken_DigestEncryptUpdate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DigestEncryptUpdateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CryptographicTokenServer).DigestEncryptUpdate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CryptographicToken_DigestEncryptUpdate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CryptographicTokenServer).DigestEncryptUpdate(ctx, req.(*DigestEncryptUpdateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CryptographicToken_DecryptDigestUpdate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DecryptDigestUpdateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CryptographicTokenServer).DecryptDigestUpdate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CryptographicToken_DecryptDigestUpdate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CryptographicTokenServer).DecryptDigestUpdate(ctx, req.(*DecryptDigestUpdateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CryptographicToken_SignEncryptUpdate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SignEncryptUpdateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CryptographicTokenServer).SignEncryptUpdate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CryptographicToken_SignEncryptUpdate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CryptographicTokenServer).SignEncryptUpdate(ctx, req.(*SignEncryptUpdateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CryptographicToken_DecryptVerifyUpdate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DecryptVerifyUpdateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CryptographicTokenServer).DecryptVerifyUpdate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CryptographicToken_DecryptVerifyUpdate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CryptographicTokenServer).DecryptVerifyUpdate(ctx, req.(*DecryptVerifyUpdateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CryptographicToken_GenerateKey_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GenerateKeyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CryptographicTokenServer).GenerateKey(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CryptographicToken_GenerateKey_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CryptographicTokenServer).GenerateKey(ctx, req.(*GenerateKeyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CryptographicToken_GenerateKeyPair_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GenerateKeyPairRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CryptographicTokenServer).GenerateKeyPair(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CryptographicToken_GenerateKeyPair_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CryptographicTokenServer).GenerateKeyPair(ctx, req.(*GenerateKeyPairRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CryptographicToken_WrapKey_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(WrapKeyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CryptographicTokenServer).WrapKey(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CryptographicToken_WrapKey_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CryptographicTokenServer).WrapKey(ctx, req.(*WrapKeyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CryptographicToken_UnwrapKey_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UnwrapKeyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CryptographicTokenServer).UnwrapKey(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CryptographicToken_UnwrapKey_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CryptographicTokenServer).UnwrapKey(ctx, req.(*UnwrapKeyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CryptographicToken_DeriveKey_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeriveKeyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CryptographicTokenServer).DeriveKey(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CryptographicToken_DeriveKey_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CryptographicTokenServer).DeriveKey(ctx, req.(*DeriveKeyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CryptographicToken_SeedRandom_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SeedRandomRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CryptographicTokenServer).SeedRandom(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CryptographicToken_SeedRandom_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CryptographicTokenServer).SeedRandom(ctx, req.(*SeedRandomRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CryptographicToken_GenerateRandom_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GenerateRandomRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CryptographicTokenServer).GenerateRandom(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CryptographicToken_GenerateRandom_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CryptographicTokenServer).GenerateRandom(ctx, req.(*GenerateRandomRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CryptographicToken_GetFunctionStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetFunctionStatusRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CryptographicTokenServer).GetFunctionStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CryptographicToken_GetFunctionStatus_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CryptographicTokenServer).GetFunctionStatus(ctx, req.(*GetFunctionStatusRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CryptographicToken_CancelFunction_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CancelFunctionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CryptographicTokenServer).CancelFunction(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CryptographicToken_CancelFunction_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CryptographicTokenServer).CancelFunction(ctx, req.(*CancelFunctionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// CryptographicToken_ServiceDesc is the grpc.ServiceDesc for CryptographicToken service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var CryptographicToken_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "pb.CryptographicToken",
	HandlerType: (*CryptographicTokenServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Initialize",
			Handler:    _CryptographicToken_Initialize_Handler,
		},
		{
			MethodName: "Finalize",
			Handler:    _CryptographicToken_Finalize_Handler,
		},
		{
			MethodName: "GetInfo",
			Handler:    _CryptographicToken_GetInfo_Handler,
		},
		{
			MethodName: "GetFunctionList",
			Handler:    _CryptographicToken_GetFunctionList_Handler,
		},
		{
			MethodName: "GetInterfaceList",
			Handler:    _CryptographicToken_GetInterfaceList_Handler,
		},
		{
			MethodName: "GetInterface",
			Handler:    _CryptographicToken_GetInterface_Handler,
		},
		{
			MethodName: "GetSlotList",
			Handler:    _CryptographicToken_GetSlotList_Handler,
		},
		{
			MethodName: "GetSlotInfo",
			Handler:    _CryptographicToken_GetSlotInfo_Handler,
		},
		{
			MethodName: "GetTokenInfo",
			Handler:    _CryptographicToken_GetTokenInfo_Handler,
		},
		{
			MethodName: "WaitForSlotEvent",
			Handler:    _CryptographicToken_WaitForSlotEvent_Handler,
		},
		{
			MethodName: "GetMechanismList",
			Handler:    _CryptographicToken_GetMechanismList_Handler,
		},
		{
			MethodName: "GetMechanismInfo",
			Handler:    _CryptographicToken_GetMechanismInfo_Handler,
		},
		{
			MethodName: "InitToken",
			Handler:    _CryptographicToken_InitToken_Handler,
		},
		{
			MethodName: "InitPIN",
			Handler:    _CryptographicToken_InitPIN_Handler,
		},
		{
			MethodName: "SetPIN",
			Handler:    _CryptographicToken_SetPIN_Handler,
		},
		{
			MethodName: "OpenSession",
			Handler:    _CryptographicToken_OpenSession_Handler,
		},
		{
			MethodName: "CloseSession",
			Handler:    _CryptographicToken_CloseSession_Handler,
		},
		{
			MethodName: "CloseAllSessions",
			Handler:    _CryptographicToken_CloseAllSessions_Handler,
		},
		{
			MethodName: "GetSessionInfo",
			Handler:    _CryptographicToken_GetSessionInfo_Handler,
		},
		{
			MethodName: "SessionCancel",
			Handler:    _CryptographicToken_SessionCancel_Handler,
		},
		{
			MethodName: "CreateObject",
			Handler:    _CryptographicToken_CreateObject_Handler,
		},
		{
			MethodName: "CopyObject",
			Handler:    _CryptographicToken_CopyObject_Handler,
		},
		{
			MethodName: "DestroyObject",
			Handler:    _CryptographicToken_DestroyObject_Handler,
		},
		{
			MethodName: "GetObjectSize",
			Handler:    _CryptographicToken_GetObjectSize_Handler,
		},
		{
			MethodName: "GetAttributeValue",
			Handler:    _CryptographicToken_GetAttributeValue_Handler,
		},
		{
			MethodName: "SetAttributeValue",
			Handler:    _CryptographicToken_SetAttributeValue_Handler,
		},
		{
			MethodName: "FindObjectsInit",
			Handler:    _CryptographicToken_FindObjectsInit_Handler,
		},
		{
			MethodName: "FindObjects",
			Handler:    _CryptographicToken_FindObjects_Handler,
		},
		{
			MethodName: "FindObjectsFinal",
			Handler:    _CryptographicToken_FindObjectsFinal_Handler,
		},
		{
			MethodName: "EncryptInit",
			Handler:    _CryptographicToken_EncryptInit_Handler,
		},
		{
			MethodName: "Encrypt",
			Handler:    _CryptographicToken_Encrypt_Handler,
		},
		{
			MethodName: "EncryptUpdate",
			Handler:    _CryptographicToken_EncryptUpdate_Handler,
		},
		{
			MethodName: "EncryptFinal",
			Handler:    _CryptographicToken_EncryptFinal_Handler,
		},
		{
			MethodName: "EncryptMessageInit",
			Handler:    _CryptographicToken_EncryptMessageInit_Handler,
		},
		{
			MethodName: "EncryptMessage",
			Handler:    _CryptographicToken_EncryptMessage_Handler,
		},
		{
			MethodName: "EncryptMessageBegin",
			Handler:    _CryptographicToken_EncryptMessageBegin_Handler,
		},
		{
			MethodName: "EncryptMessageNext",
			Handler:    _CryptographicToken_EncryptMessageNext_Handler,
		},
		{
			MethodName: "EncryptMessageFinal",
			Handler:    _CryptographicToken_EncryptMessageFinal_Handler,
		},
		{
			MethodName: "DecryptInit",
			Handler:    _CryptographicToken_DecryptInit_Handler,
		},
		{
			MethodName: "Decrypt",
			Handler:    _CryptographicToken_Decrypt_Handler,
		},
		{
			MethodName: "DecryptUpdate",
			Handler:    _CryptographicToken_DecryptUpdate_Handler,
		},
		{
			MethodName: "DecryptFinal",
			Handler:    _CryptographicToken_DecryptFinal_Handler,
		},
		{
			MethodName: "DecryptMessageInit",
			Handler:    _CryptographicToken_DecryptMessageInit_Handler,
		},
		{
			MethodName: "DecryptMessage",
			Handler:    _CryptographicToken_DecryptMessage_Handler,
		},
		{
			MethodName: "DecryptMessageBegin",
			Handler:    _CryptographicToken_DecryptMessageBegin_Handler,
		},
		{
			MethodName: "DecryptMessageNext",
			Handler:    _CryptographicToken_DecryptMessageNext_Handler,
		},
		{
			MethodName: "MessageDecryptFinal",
			Handler:    _CryptographicToken_MessageDecryptFinal_Handler,
		},
		{
			MethodName: "DigestInit",
			Handler:    _CryptographicToken_DigestInit_Handler,
		},
		{
			MethodName: "Digest",
			Handler:    _CryptographicToken_Digest_Handler,
		},
		{
			MethodName: "DigestUpdate",
			Handler:    _CryptographicToken_DigestUpdate_Handler,
		},
		{
			MethodName: "DigestKey",
			Handler:    _CryptographicToken_DigestKey_Handler,
		},
		{
			MethodName: "DigestFinal",
			Handler:    _CryptographicToken_DigestFinal_Handler,
		},
		{
			MethodName: "SignInit",
			Handler:    _CryptographicToken_SignInit_Handler,
		},
		{
			MethodName: "Sign",
			Handler:    _CryptographicToken_Sign_Handler,
		},
		{
			MethodName: "SignUpdate",
			Handler:    _CryptographicToken_SignUpdate_Handler,
		},
		{
			MethodName: "SignFinal",
			Handler:    _CryptographicToken_SignFinal_Handler,
		},
		{
			MethodName: "SignRecoverInit",
			Handler:    _CryptographicToken_SignRecoverInit_Handler,
		},
		{
			MethodName: "SignRecover",
			Handler:    _CryptographicToken_SignRecover_Handler,
		},
		{
			MethodName: "SignMessageInit",
			Handler:    _CryptographicToken_SignMessageInit_Handler,
		},
		{
			MethodName: "SignMessage",
			Handler:    _CryptographicToken_SignMessage_Handler,
		},
		{
			MethodName: "SignMessageBegin",
			Handler:    _CryptographicToken_SignMessageBegin_Handler,
		},
		{
			MethodName: "SignMessageNext",
			Handler:    _CryptographicToken_SignMessageNext_Handler,
		},
		{
			MethodName: "SignMessageFinal",
			Handler:    _CryptographicToken_SignMessageFinal_Handler,
		},
		{
			MethodName: "VerifyInit",
			Handler:    _CryptographicToken_VerifyInit_Handler,
		},
		{
			MethodName: "Verify",
			Handler:    _CryptographicToken_Verify_Handler,
		},
		{
			MethodName: "VerifyUpdate",
			Handler:    _CryptographicToken_VerifyUpdate_Handler,
		},
		{
			MethodName: "VerifyFinal",
			Handler:    _CryptographicToken_VerifyFinal_Handler,
		},
		{
			MethodName: "VerifyRecoverInit",
			Handler:    _CryptographicToken_VerifyRecoverInit_Handler,
		},
		{
			MethodName: "VerifyRecover",
			Handler:    _CryptographicToken_VerifyRecover_Handler,
		},
		{
			MethodName: "VerifyMessageInit",
			Handler:    _CryptographicToken_VerifyMessageInit_Handler,
		},
		{
			MethodName: "VerifyMessage",
			Handler:    _CryptographicToken_VerifyMessage_Handler,
		},
		{
			MethodName: "VerifyMessageBegin",
			Handler:    _CryptographicToken_VerifyMessageBegin_Handler,
		},
		{
			MethodName: "VerifyMessageNext",
			Handler:    _CryptographicToken_VerifyMessageNext_Handler,
		},
		{
			MethodName: "VerifyMessageFinal",
			Handler:    _CryptographicToken_VerifyMessageFinal_Handler,
		},
		{
			MethodName: "DigestEncryptUpdate",
			Handler:    _CryptographicToken_DigestEncryptUpdate_Handler,
		},
		{
			MethodName: "DecryptDigestUpdate",
			Handler:    _CryptographicToken_DecryptDigestUpdate_Handler,
		},
		{
			MethodName: "SignEncryptUpdate",
			Handler:    _CryptographicToken_SignEncryptUpdate_Handler,
		},
		{
			MethodName: "DecryptVerifyUpdate",
			Handler:    _CryptographicToken_DecryptVerifyUpdate_Handler,
		},
		{
			MethodName: "GenerateKey",
			Handler:    _CryptographicToken_GenerateKey_Handler,
		},
		{
			MethodName: "GenerateKeyPair",
			Handler:    _CryptographicToken_GenerateKeyPair_Handler,
		},
		{
			MethodName: "WrapKey",
			Handler:    _CryptographicToken_WrapKey_Handler,
		},
		{
			MethodName: "UnwrapKey",
			Handler:    _CryptographicToken_UnwrapKey_Handler,
		},
		{
			MethodName: "DeriveKey",
			Handler:    _CryptographicToken_DeriveKey_Handler,
		},
		{
			MethodName: "SeedRandom",
			Handler:    _CryptographicToken_SeedRandom_Handler,
		},
		{
			MethodName: "GenerateRandom",
			Handler:    _CryptographicToken_GenerateRandom_Handler,
		},
		{
			MethodName: "GetFunctionStatus",
			Handler:    _CryptographicToken_GetFunctionStatus_Handler,
		},
		{
			MethodName: "CancelFunction",
			Handler:    _CryptographicToken_CancelFunction_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "pb/pkcs11.proto",
}
